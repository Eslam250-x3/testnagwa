<!DOCTYPE html>
<html lang="ar" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ù…ØªØ±Ø¬Ù… Ø§Ù„Ø£Ø³Ø¦Ù„Ø© Ø§Ù„Ù…Ø­ØªØ±Ù (Ù…Ø¹ Ù…Ø­Ø±Ø± Ø±ÙŠØ§Ø¶ÙŠ Ù…ØªÙƒØ§Ù…Ù„)</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    
    <!-- MathLive for LaTeX editing -->
    <script src="https://unpkg.com/mathlive"></script>
        <!-- Fabric.js for simple image annotation/editor -->
        <script src="https://cdnjs.cloudflare.com/ajax/libs/fabric.js/5.3.0/fabric.min.js"></script>
    
    <!-- DOMPurify for security -->
    <script src="https://cdn.jsdelivr.net/npm/dompurify@3.0.6/dist/purify.min.js"></script>
    
    <!-- Diff Match Patch for comparing text -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/diff_match_patch/20121119/diff_match_patch.js"></script>
    
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Cairo:wght@400;600;700&display=swap" rel="stylesheet">
    <style>
        :root {
            --bg-color: #f3f4f6;
            --text-color: #1f2937;
            --card-bg: #ffffff;
            --card-border: #e5e7eb;
            --input-bg: #ffffff;
            --input-border: #d1d5db;
            --primary-color: #4f46e5;
            --primary-hover: #4338ca;
            --secondary-text: #6b7280;
            --success-color: #10b981;
            --error-color: #ef4444;
            --highlight-bg: #fef9c3;
            --diff-ins-bg: #ddfbe9;
            --diff-del-bg: #fce8e9;
        }
        [data-theme="dark"] {
            --bg-color: #111827;
            --text-color: #f9fafb;
            --card-bg: #1f2937;
            --card-border: #374151;
            --input-bg: #374151;
            --input-border: #4b5563;
            --primary-color: #6366f1;
            --primary-hover: #818cf8;
            --secondary-text: #9ca3af;
            --highlight-bg: #4d4318;
            --diff-ins-bg: #133825;
            --diff-del-bg: #411a1d;
        }
        body { font-family: 'Cairo', sans-serif; background-color: var(--bg-color); color: var(--text-color); transition: background-color 0.3s, color 0.3s; }
        .main-card, .preview-card { background-color: var(--card-bg); border: 1px solid var(--card-border); transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1); }
        input, select, textarea { background-color: var(--input-bg); border: 1px solid var(--input-border); }
        .dragover { border-color: var(--primary-color); background-color: color-mix(in srgb, var(--primary-color) 10%, var(--bg-color)); }
        .api-selector input[type="radio"]:checked + label { border-color: var(--primary-color); background-color: color-mix(in srgb, var(--primary-color) 15%, var(--card-bg)); color: var(--primary-color); }
        .alert { transition: all 0.5s ease-in-out; opacity: 1; transform: translateX(0); }
        .alert.fade-out { opacity: 0; transform: translateX(100%); }
        .search-highlight, mark.search-highlight { background-color: var(--highlight-bg); color: var(--text-color); border-radius: 3px; padding: 0 2px; }
        #saveIndicator { font-size: 0.85rem; color: var(--secondary-text); }
        #saveIndicator.saved { color: var(--success-color); }
        
        /* Accordion Styles */
        .accordion-header { width: 100%; padding: 1rem 1.5rem; text-align: right; font-weight: 700; font-size: 1.125rem; border-radius: 0.75rem; background-color: color-mix(in srgb, var(--primary-color) 8%, var(--card-bg)); transition: background-color 0.2s; cursor: pointer; }
        .accordion-header:hover { background-color: color-mix(in srgb, var(--primary-color) 15%, var(--card-bg)); }
        .accordion-content { max-height: 0; overflow: hidden; transition: max-height 0.4s ease-in-out; background-color: var(--card-bg); border-top: 1px solid var(--card-border); }
        .accordion-content.open { padding: 1.5rem; }

        /* Diff View Styles */
        .diff-view { padding: 0.75rem; border-radius: 0.5rem; background-color: var(--bg-color); border: 1px solid var(--card-border); font-family: monospace; white-space: pre-wrap; word-wrap: break-word; }
        .diff-view ins { background-color: var(--diff-ins-bg); text-decoration: none; }
        .diff-view del { background-color: var(--diff-del-bg); text-decoration: line-through; }

        /* Status Indicator */
        .status-dot { width: 10px; height: 10px; border-radius: 50%; display: inline-block; margin-left: 8px; }
        .status-translated { background-color: var(--success-color); }
        .status-edited { background-color: #f59e0b; } /* Amber 500 */

        /* Styles for MathLive Fields */
        .editable-preview-field { background-color: var(--input-bg); border: 1px solid var(--input-border); border-radius: 0.5rem; padding: 0.75rem; min-height: 80px; }
        /* MathLive default look (editable) */
        math-field { border: 1px solid var(--input-border); padding: 2px 6px; border-radius: 4px; font-size: 1.1em; display: inline-block; background: var(--input-bg); min-width: 20px; margin: 2px; max-width: 100%; white-space: nowrap; }
        /* Higher-fidelity preview to match source system: make formulas look inline and unboxed inside preview */
        .editable-preview-field math-field { border: 0; background: transparent; padding: 0 2px; box-shadow: none; }
        .editable-preview-field .content-root { line-height: 1.8; }
        .editable-preview-field .content-root p { margin: .25rem 0; }
        /* Approximate Lexical theme blocks so content spacing matches original */
        .LexicalTheme__paragraph { white-space: pre-wrap; margin: .25rem 0; }
        .LexicalTheme__image img { max-width: 100%; height: auto; }
        math-field:focus-within { background-color: color-mix(in srgb, var(--primary-color) 10%, var(--input-bg)); box-shadow: 0 0 0 2px var(--primary-color); outline: none; }
            /* Visual blank for underscores in preview (does not persist to JSON) */
            .blank-slot { display: inline-block; min-width: 1.8em; border-bottom: 2px solid currentColor; vertical-align: baseline; line-height: 1.2; margin: 0 0.15em; }
        /* Tables inside editable preview */
        .editable-preview-field table { width: 100%; border-collapse: collapse; direction: rtl; }
        .editable-preview-field th, .editable-preview-field td { border: 1px solid var(--card-border); padding: 6px 8px; vertical-align: top; }
        .editable-preview-field thead { background-color: color-mix(in srgb, var(--primary-color) 8%, var(--card-bg)); }
        /* Make table cells editable */
        .editable-preview-field td, .editable-preview-field th { 
            position: relative; 
            min-height: 1.5em; 
            cursor: text; 
        }
        .editable-preview-field td:focus, .editable-preview-field th:focus { 
            outline: 2px solid var(--primary-color); 
            outline-offset: -2px; 
            background-color: color-mix(in srgb, var(--primary-color) 5%, var(--input-bg)); 
        }
    </style>
</head>
<body class="text-gray-800">
    <div id="alertContainer" class="fixed top-0 right-0 p-4 w-full max-w-md z-50 space-y-3"></div>

    <div class="container mx-auto p-4 md:p-8 max-w-7xl">
        <div class="flex justify-between items-center mb-4">
            <h1 class="text-4xl md:text-5xl font-bold" style="color: var(--primary-color);">ğŸŒ Ù…ØªØ±Ø¬Ù… Ø§Ù„Ø£Ø³Ø¦Ù„Ø© Ø§Ù„Ù…Ø­ØªØ±Ù</h1>
            <div class="flex items-center gap-4">
                <span id="saveIndicator" aria-live="polite">â€”</span>
                <button id="theme-toggle" class="text-2xl">â˜€ï¸</button>
                <button id="newSessionBtn" class="bg-red-500 text-white font-semibold py-2 px-4 rounded-lg hover:bg-red-600 transition">Ø¨Ø¯Ø¡ Ø¬Ù„Ø³Ø© Ø¬Ø¯ÙŠØ¯Ø©</button>
            </div>
        </div>
        <p class="mt-2 mb-8 text-center text-lg" style="color: var(--secondary-text);">ØªØ±Ø¬Ù…Ø© Ù…Ù„ÙØ§Øª JSONØŒ Ù…Ø¹ Ø§Ù„Ù…Ø¹Ø§ÙŠÙ†Ø© ÙˆØ§Ù„ØªØ¹Ø¯ÙŠÙ„ØŒ ÙˆØ¯Ø¹Ù… Ø§Ù„Ù…Ø¹Ø§Ø¯Ù„Ø§Øª Ø§Ù„Ø±ÙŠØ§Ø¶ÙŠØ©.</p>
        
        <div id="setupSection" class="main-card p-6 rounded-2xl shadow-lg mb-6">
            <h3 class="text-2xl font-bold mb-4 border-b-2 pb-2" style="color: var(--primary-color); border-color: var(--primary-color-light);">Ø§Ù„Ø®Ø·ÙˆØ© 1: Ø§Ù„Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª ÙˆØ±ÙØ¹ Ø§Ù„Ù…Ù„ÙØ§Øª</h3>
            <div class="grid md:grid-cols-2 gap-6">
                <div>
                    <div class="mb-6">
                        <label class="block mb-2 font-semibold">Ø§Ø®ØªØ± Ù…ÙØ²ÙˆÙ‘Ø¯ Ø§Ù„Ø®Ø¯Ù…Ø©:</label>
                        <div class="api-selector grid grid-cols-3 gap-4">
                            <div>
                                <input type="radio" id="geminiProvider" name="apiProvider" value="gemini" class="hidden" checked>
                                <label for="geminiProvider" class="block text-center p-4 border-2 rounded-lg cursor-pointer transition"><span class="font-bold">ğŸ¤– Gemini</span></label>
                            </div>
                            <div>
                                <input type="radio" id="chatgptProvider" name="apiProvider" value="chatgpt" class="hidden">
                                <label for="chatgptProvider" class="block text-center p-4 border-2 rounded-lg cursor-pointer transition"><span class="font-bold">ğŸ’¬ ChatGPT</span></label>
                            </div>
                            <div>
                                <input type="radio" id="localModelProvider" name="apiProvider" value="local" class="hidden">
                                <label for="localModelProvider" class="block text-center p-4 border-2 rounded-lg cursor-pointer transition"><span class="font-bold">ğŸ–¥ï¸ Ù†Ù…ÙˆØ°Ø¬ Ù…Ø­Ù„ÙŠ</span></label>
                            </div>
                        </div>
                    </div>

                    <div id="geminiKeyGroup" class="mb-6">
                        <label for="geminiKey" class="block mb-2 font-semibold">Ù…ÙØªØ§Ø­ Gemini API:</label>
                        <input type="password" id="geminiKey" placeholder="ÙŠØ¨Ø¯Ø£ Ø¨Ù€ AIza..." class="w-full p-3 rounded-lg focus:ring-2 transition" style="border-color: var(--input-border);">
                    </div>
                    <div id="chatgptKeyGroup" class="mb-6 hidden">
                        <label for="chatgptKey" class="block mb-2 font-semibold">Ù…ÙØªØ§Ø­ OpenAI API:</label>
                        <input type="password" id="chatgptKey" placeholder="ÙŠØ¨Ø¯Ø£ Ø¨Ù€ sk-..." class="w-full p-3 rounded-lg focus:ring-2 transition" style="border-color: var(--input-border);">
                    </div>
                    <div id="localModelGroup" class="mb-6 hidden">
                        <label for="localModelUrl" class="block mb-2 font-semibold">Ø¹Ù†ÙˆØ§Ù† URL Ù„Ø®Ø§Ø¯Ù… Ollama:</label>
                        <input type="text" id="localModelUrl" placeholder="http://localhost:11434/api/generate" class="w-full p-3 rounded-lg focus:ring-2 transition mb-2" style="border-color: var(--input-border);">
                        <label for="localModelName" class="block mb-2 font-semibold">Ø§Ø³Ù… Ø§Ù„Ù†Ù…ÙˆØ°Ø¬ (Ù…Ø«Ø§Ù„: gemma:7b):</label>
                        <input type="text" id="localModelName" placeholder="gemma:7b" class="w-full p-3 rounded-lg focus:ring-2 transition" style="border-color: var(--input-border);">
                    </div>

                    <div class="mb-3">
                        <label class="inline-flex items-center gap-2">
                            <input id="ephemeralKeysCheckbox" type="checkbox" class="h-4 w-4 rounded focus:ring-2" style="color: var(--primary-color);">
                            <span class="text-sm font-medium">Ø¹Ø¯Ù… Ø­ÙØ¸ Ù…ÙØ§ØªÙŠØ­ API Ù…Ø­Ù„ÙŠÙ‹Ø§ (Ø¬Ù„Ø³Ø© Ù…Ø¤Ù‚ØªØ© ÙÙ‚Ø·)</span>
                        </label>
                    </div>
                    <div class="mb-3">
                        <label class="inline-flex items-center gap-2">
                            <input id="useTmCheckbox" type="checkbox" class="h-4 w-4 rounded focus:ring-2" checked style="color: var(--primary-color);">
                            <span class="text-sm font-medium">Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø°Ø§ÙƒØ±Ø© Ø§Ù„ØªØ±Ø¬Ù…Ø© (TM)</span>
                        </label>
                    </div>
                    <div class="mb-6">
                        <label class="inline-flex items-center gap-2">
                            <input id="useProofreadCheckbox" type="checkbox" class="h-4 w-4 rounded focus:ring-2" style="color: var(--primary-color);">
                            <span class="text-sm font-medium">ØªÙØ¹ÙŠÙ„ Ø§Ù„ØªØ¯Ù‚ÙŠÙ‚ Ø§Ù„Ù„ØºÙˆÙŠ Ø§Ù„Ø¢Ù„ÙŠ Ø¨Ø¹Ø¯ Ø§Ù„ØªØ±Ø¬Ù…Ø©</span>
                        </label>
                    </div>

                    <div class="flex items-center justify-between mb-6 p-3 rounded-lg" style="background-color: color-mix(in srgb, var(--primary-color) 5%, var(--card-bg));">
                        <button id="manageSubjectsBtn" type="button" class="font-semibold" style="color: var(--primary-color);">ğŸ“š Ø¥Ø¯Ø§Ø±Ø© Ø§Ù„Ù…ÙˆØ§Ø¯ ÙˆØ§Ù„ØµÙÙˆÙ</button>
                    </div>
                    
                    <div class="flex items-center justify-between mb-6 p-3 rounded-lg" style="background-color: color-mix(in srgb, var(--primary-color) 5%, var(--card-bg));">
                        <button id="manageGlossaryBtn" type="button" class="font-semibold" style="color: var(--primary-color);">ğŸ“– Ø¥Ø¯Ø§Ø±Ø© Ø§Ù„Ù‚Ø§Ù…ÙˆØ³ Ø§Ù„Ù…Ø®ØµØµ</button>
                        <div class="flex items-center">
                            <input id="useGlossaryCheckbox" type="checkbox" class="h-4 w-4 rounded focus:ring-2" style="color: var(--primary-color);">
                            <label for="useGlossaryCheckbox" class="mr-2 text-sm font-medium">Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø§Ù„Ù‚Ø§Ù…ÙˆØ³</label>
                        </div>
                    </div>
                    
                    <div class="flex items-center justify-between p-3 rounded-lg" style="background-color: color-mix(in srgb, var(--primary-color) 5%, var(--card-bg));">
                        <button id="manageIdsBtn" type="button" class="font-semibold" style="color: var(--primary-color);">ğŸ†” Ø¥Ø¯Ø§Ø±Ø© Ù…Ø¹Ø±ÙØ§Øª Ø§Ù„Ø£Ø³Ø¦Ù„Ø© (mapped_id)</button>
                    </div>
                </div>

                <div>
                    <div class="mb-4">
                        <label class="block mb-2 font-semibold">Ù…Ù„ÙØ§Øª Ø§Ù„Ø£Ø³Ø¦Ù„Ø© (JSON):</label>
                        <div id="fileUpload" class="border-2 border-dashed rounded-lg p-8 text-center cursor-pointer transition" style="border-color: var(--input-border);">
                            <div style="color: var(--primary-color);" class="text-4xl mb-2">ğŸ“¤</div>
                            <p class="font-semibold">Ø§Ø³Ø­Ø¨ ÙˆØ£ÙÙ„Øª Ø§Ù„Ù…Ù„ÙØ§Øª Ù‡Ù†Ø§ Ø£Ùˆ Ø§Ù†Ù‚Ø± Ù„Ù„Ø§Ø®ØªÙŠØ§Ø±</p>
                            <p class="text-sm mt-1" style="color: var(--secondary-text);">ÙŠØ¬Ø¨ Ø£Ù† ØªÙƒÙˆÙ† Ø§Ù„Ù…Ù„ÙØ§Øª Ø¨ØµÙŠØºØ© JSON</p>
                            <input type="file" id="fileInput" multiple accept=".json" class="hidden">
                        </div>
                    </div>
                    <div id="fileList" class="space-y-2 max-h-40 overflow-y-auto"></div>
                </div>
            </div>
            
            <button id="translateBtn" class="w-full text-white font-bold py-3 px-6 rounded-lg transition-transform transform hover:scale-105 disabled:opacity-50 disabled:cursor-not-allowed disabled:transform-none mt-8" style="background-color: var(--primary-color);">
                ØªØ±Ø¬Ù…Ø© Ø§Ù„Ù…Ù„ÙØ§Øª (Ctrl + Enter)
            </button>
        </div>

        <div id="progressContainer" class="hidden main-card p-6 rounded-2xl shadow-lg mb-6 text-center">
            <div class="w-16 h-16 border-4 border-dashed rounded-full animate-spin mx-auto" style="border-color: var(--primary-color); border-top-color: transparent;"></div>
            <p id="progressText" class="mt-4 text-lg font-semibold">Ø¬Ø§Ø±ÙŠ Ø§Ù„ØªØ±Ø¬Ù…Ø©...</p>
            <div class="mt-3">
                <button id="cancelTranslationBtn" class="px-4 py-2 rounded-lg bg-red-500 text-white hover:bg-red-600">Ø¥Ù„ØºØ§Ø¡</button>
            </div>
        </div>
        
        <div id="analyticsSection" class="hidden main-card p-6 rounded-2xl shadow-lg mb-6">
            <h3 class="text-2xl font-bold mb-4" style="color: var(--primary-color);">ğŸ“Š ØªØ­Ù„ÙŠÙ„ Ø§Ù„ØªØ±Ø¬Ù…Ø©</h3>
            <div id="statsContainer" class="grid grid-cols-2 md:grid-cols-4 gap-4 text-center"></div>
        </div>

        <div id="previewSection" class="hidden">
            <div class="main-card p-4 rounded-2xl shadow-lg mb-6">
                <div class="flex flex-wrap gap-4 items-center justify-between">
                    <div>
                        <h3 class="text-2xl font-bold" style="color: var(--success-color);">Ø§Ù„Ø®Ø·ÙˆØ© 2: Ù…Ø¹Ø§ÙŠÙ†Ø© ÙˆØªØ¹Ø¯ÙŠÙ„ Ø§Ù„ØªØ±Ø¬Ù…Ø©</h3>
                        <p class="mt-1" style="color: var(--secondary-text);">Ø±Ø§Ø¬Ø¹ Ø§Ù„ØªØ±Ø§Ø¬Ù…ØŒ Ø¹Ø¯Ù‘Ù„Ù‡Ø§ØŒ ÙˆÙ‚Ø§Ø±Ù†Ù‡Ø§ Ø¨Ø§Ù„Ù†Øµ Ø§Ù„Ø£ØµÙ„ÙŠ.</p>
                    </div>
                    <div class="flex items-center gap-2">
                        <button id="undoBtn" disabled class="px-3 py-2 rounded-lg disabled:opacity-50">â†©ï¸ ØªØ±Ø§Ø¬Ø¹</button>
                        <button id="redoBtn" disabled class="px-3 py-2 rounded-lg disabled:opacity-50">â†ªï¸ Ø¥Ø¹Ø§Ø¯Ø©</button>
                        <button id="openAnnotatorBtn" class="px-3 py-2 rounded-lg" title="ØªØ­Ø±ÙŠØ± Ø§Ù„Ù†Øµ ÙÙˆÙ‚ Ø§Ù„ØµÙˆØ± (Ø£Ø±Ù‚Ø§Ù…/Ø±Ù…ÙˆØ²)">ğŸ–Šï¸ Ù…Ø­Ø±Ø± Ø§Ù„ØµÙˆØ±</button>
                    </div>
                </div>
                <div class="preview-controls my-4 p-4 rounded-lg" style="background-color: color-mix(in srgb, var(--primary-color) 5%, var(--card-bg));">
                    <div class="flex flex-wrap gap-4 items-center">
                        <div class="flex-grow">
                            <input type="text" id="searchPreview" placeholder="Ø§Ù„Ø¨Ø­Ø« ÙÙŠ Ø§Ù„Ù†Øµ Ø§Ù„Ø£ØµÙ„ÙŠ..." class="w-full p-2 border rounded-lg">
                        </div>
                    </div>
                </div>
            </div>

            <div id="previewContainer" class="space-y-4"></div>

            <div class="main-card mt-8 p-4 rounded-2xl shadow-lg flex items-center justify-center gap-4">
                <label for="exportFormat" class="font-semibold">ØªÙ†Ø³ÙŠÙ‚ Ø§Ù„ØªØµØ¯ÙŠØ±:</label>
                <select id="exportFormat" class="p-2 rounded-lg">
                    <option value="json">JSON</option>
                    <option value="csv">CSV</option>
                </select>
                <button id="exportBtn" class="text-white font-bold py-3 px-6 rounded-lg transition-transform transform hover:scale-105" style="background-color: var(--success-color);">
                    ØªØµØ¯ÙŠØ± Ø§Ù„Ù…Ù„ÙØ§Øª Ø§Ù„Ù…ØªØ±Ø¬Ù…Ø©
                </button>
            </div>
        </div>
    </div>

    <!-- Modals (Glossary, Mapped IDs, Subjects) -->
        <!-- Image Annotator Modal -->
        <div id="imageAnnotatorModal" class="hidden fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center p-4 z-50">
            <div class="main-card rounded-2xl shadow-xl p-4 w-full max-w-4xl">
                <div class="flex justify-between items-center mb-2">
                    <h3 class="text-xl font-bold" style="color: var(--primary-color);">ØªØ­Ø±ÙŠØ± Ù†Øµ ÙÙˆÙ‚ Ø§Ù„ØµÙˆØ±Ø©</h3>
                    <button id="imageAnnotatorClose" class="text-2xl">&times;</button>
                </div>
                <div class="w-full overflow-auto" style="max-height:70vh">
                    <canvas id="imageAnnotatorCanvas" class="w-full border" style="border-color: var(--card-border);"></canvas>
                </div>
                <div class="flex justify-end gap-2 mt-3">
                    <button id="imageAnnotatorSave" class="px-4 py-2 rounded-lg text-white" style="background-color: var(--success-color);">Ø­ÙØ¸</button>
                </div>
            </div>
        </div>
    <div id="glossaryModal" class="hidden fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center p-4 z-50">
        <div class="main-card rounded-2xl shadow-xl p-6 w-full max-w-2xl transform transition-all" role="dialog" aria-labelledby="glossaryTitle">
            <div class="flex justify-between items-center">
                <h3 id="glossaryTitle" class="text-2xl font-bold" style="color: var(--primary-color);">Ø§Ù„Ù‚Ø§Ù…ÙˆØ³ Ø§Ù„Ù…Ø®ØµØµ</h3>
                <button id="closeGlossaryModalBtn" class="text-2xl hover:opacity-75" aria-label="Ø¥ØºÙ„Ø§Ù‚">&times;</button>
            </div>
            <p class="text-sm mt-1 mb-4" style="color: var(--secondary-text);">Ø£Ø¶Ù Ø§Ù„Ù…ØµØ·Ù„Ø­Ø§Øª ÙˆØªØ±Ø¬Ù…ØªÙ‡Ø§ Ø§Ù„Ù…Ø¹ØªÙ…Ø¯Ø© Ù„Ø¶Ù…Ø§Ù† Ø§Ù„Ø§ØªØ³Ø§Ù‚.</p>
            <div class="flex flex-wrap gap-2 mb-4">
                <button id="importGlossaryBtn" class="flex-1 px-4 py-2 text-white rounded-lg" style="background-color: var(--primary-color);">Ø§Ø³ØªÙŠØ±Ø§Ø¯</button>
                <button id="exportGlossaryBtn" class="flex-1 px-4 py-2 text-white rounded-lg" style="background-color: var(--success-color);">ØªØµØ¯ÙŠØ± (CSV)</button>
                <input type="file" id="glossaryFileInput" accept=".json,.csv" class="hidden">
            </div>
            <input type="text" id="glossarySearch" placeholder="Ø§Ù„Ø¨Ø­Ø« ÙÙŠ Ø§Ù„Ù‚Ø§Ù…ÙˆØ³..." class="w-full p-2 mb-4 border rounded-lg">

            <div class="grid md:grid-cols-3 gap-4 mb-4">
                <input type="text" id="glossaryTerm" placeholder="Ø§Ù„Ù…ØµØ·Ù„Ø­ Ø§Ù„Ø£ØµÙ„ÙŠ" class="md:col-span-1 block w-full p-2 border rounded-md shadow-sm">
                <input type="text" id="glossaryTranslation" placeholder="Ø§Ù„ØªØ±Ø¬Ù…Ø© Ø§Ù„Ù…Ø¹ØªÙ…Ø¯Ø©" class="md:col-span-1 block w-full p-2 border rounded-md shadow-sm">
                <select id="glossaryCategory" class="md:col-span-1 block w-full p-2 border rounded-md shadow-sm">
                    <option value="general">Ø¹Ø§Ù…</option>
                    <option value="technical">ØªÙ‚Ù†ÙŠ</option>
                    <option value="medical">Ø·Ø¨ÙŠ</option>
                    <option value="legal">Ù‚Ø§Ù†ÙˆÙ†ÙŠ</option>
                </select>
            </div>
            <button id="addGlossaryTermBtn" class="text-white px-4 py-2 rounded-lg w-full mb-4" style="background-color: var(--primary-color);">Ø¥Ø¶Ø§ÙØ© Ù…ØµØ·Ù„Ø­</button>
            <hr class="my-4" style="border-color: var(--card-border);">
            <h4 class="text-lg font-semibold mb-2">Ø§Ù„Ù…ØµØ·Ù„Ø­Ø§Øª Ø§Ù„Ù…Ø­ÙÙˆØ¸Ø©</h4>
            <div id="glossaryListContainer" class="max-h-60 overflow-y-auto p-2 rounded-md" style="background-color: var(--bg-color);"></div>
        </div>
    </div>
    
    <div id="mappedIdsModal" class="hidden fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center p-4 z-50">
        <div class="main-card rounded-2xl shadow-xl p-6 w-full max-w-2xl transform transition-all" role="dialog" aria-labelledby="mappedIdsTitle">
            <div class="flex justify-between items-center">
                <h3 id="mappedIdsTitle" class="text-2xl font-bold" style="color: var(--primary-color);">Ø¥Ø¯Ø§Ø±Ø© Ù…Ø¹Ø±ÙØ§Øª Ø§Ù„Ø£Ø³Ø¦Ù„Ø© (mapped_id)</h3>
                <button id="closeMappedIdsModalBtn" class="text-2xl hover:opacity-75" aria-label="Ø¥ØºÙ„Ø§Ù‚">&times;</button>
            </div>
            <p class="text-sm mt-1 mb-4" style="color: var(--secondary-text);">Ø£Ø¯Ø®Ù„ Ø¹Ø¯Ø¯ Ø§Ù„Ù…Ø¹Ø±ÙØ§Øª Ø§Ù„Ù…Ø·Ù„ÙˆØ¨Ø© Ø«Ù… Ø§Ø¶ØºØ· Ø¹Ù„Ù‰ Ø§Ù„Ø²Ø± Ù„Ø¬Ù„Ø¨Ù‡Ø§ ØªÙ„Ù‚Ø§Ø¦ÙŠØ§Ù‹ØŒ Ø£Ùˆ Ø£Ù„ØµÙ‚Ù‡Ø§ ÙŠØ¯ÙˆÙŠØ§Ù‹.</p>
            <div class="flex gap-2 mb-4">
                <input type="number" id="mappedIdsCount" placeholder="Ø£Ø¯Ø®Ù„ Ø§Ù„Ø¹Ø¯Ø¯" class="p-2 border rounded-lg w-1/3 text-center">
                <button id="fetchMappedIdsBtn" class="flex-1 px-4 py-2 text-sm text-white rounded-lg" style="background-color: var(--primary-color);">Ø¬Ù„Ø¨ Ø§Ù„Ø£ÙƒÙˆØ§Ø¯ Ù…Ù† Nagwa</button>
            </div>
            <textarea id="mappedIdsInput" rows="5" class="w-full p-2 rounded-lg mb-4" placeholder='["...","..."]'></textarea>
            <div class="flex items-center">
                <input id="useMappedIdsCheckbox" type="checkbox" class="h-4 w-4 rounded focus:ring-2" style="color: var(--primary-color);">
                <label for="useMappedIdsCheckbox" class="mr-2 text-sm font-medium">ØªÙØ¹ÙŠÙ„ Ø§Ø³ØªØ¨Ø¯Ø§Ù„ Ø§Ù„Ù…Ø¹Ø±ÙØ§Øª Ø¹Ù†Ø¯ Ø§Ù„ØªØµØ¯ÙŠØ±</label>
            </div>
        </div>
    </div>

    <div id="subjectsModal" class="hidden fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center p-4 z-50">
        <div class="main-card rounded-2xl shadow-xl p-6 w-full max-w-3xl transform transition-all" role="dialog" aria-labelledby="subjectsTitle">
            <div class="flex justify-between items-center">
                <h3 id="subjectsTitle" class="text-2xl font-bold" style="color: var(--primary-color);">Ø¥Ø¯Ø§Ø±Ø© Ø§Ù„Ù…ÙˆØ§Ø¯ ÙˆØ§Ù„ØµÙÙˆÙ</h3>
                <button id="closeSubjectsModalBtn" class="text-2xl hover:opacity-75" aria-label="Ø¥ØºÙ„Ø§Ù‚">&times;</button>
            </div>
            <p class="text-sm mt-1 mb-4" style="color: var(--secondary-text);">Ø§Ø®ØªØ± Ø§Ù„Ù…Ø§Ø¯Ø© ÙˆØ§Ù„ØµÙ Ù„ØªØ·Ø¨ÙŠÙ‚ ØªØ¹Ù„ÙŠÙ…Ø§Øª ØªØ±Ø¬Ù…Ø© Ù…Ø®ØµØµØ©.</p>
            <div class="grid grid-cols-1 md:grid-cols-2 gap-4 mb-4">
                <select id="subjectSelect" class="p-2 border rounded-lg w-full"></select>
                <select id="gradeSelect" class="p-2 border rounded-lg w-full"></select>
            </div>
            <h4 class="text-lg font-semibold mb-2">Ù…Ø¹Ø§ÙŠÙ†Ø© Ø§Ù„ØªØ¹Ù„ÙŠÙ…Ø§Øª (Ø§Ù„Ø¨Ø±ÙˆÙ…Ø¨Øª)</h4>
            <textarea id="promptPreview" rows="8" class="w-full p-2 rounded-lg mb-4" readonly></textarea>
            <button id="applyPromptBtn" class="w-full text-white font-bold py-2 px-4 rounded-lg" style="background-color: var(--success-color);">ØªØ·Ø¨ÙŠÙ‚ ÙˆØ­ÙØ¸</button>
        </div>
    </div>

    <script>
    const GOOGLE_SHEET_ID = '16-ant77j9ckFE7y48mOaqmMvUQrx8ZzM-ksWHaFNSUU';

    const TranslatorApp = {
        constants: {
            BATCH_SEPARATOR: "\\n|||---|||\\n",
            CONTEXT_SEPARATOR: "\\n<SEP>\\n",
            HISTORY_MAX: 20,
            CHUNK_SIZE: 40
        },

        state: {
            selectedFilesInfo: [],
            originalJsonData: [],
            translatedJsonData: [],
            glossary: [],
            activeScreen: 'setup',
            translationCache: new Map(),
            startTime: null,
            hasUnsavedChanges: false,
            selectedSubject: 'None',
            selectedGrade: 'None',
            fileStore: new Map(),
            isTranslating: false
        },

        dom: {},

        init() {
            this.cacheDomElements();
            this.bindEvents();
            this.theme.init();
            this.history.init();
            this.subjects.init();
            this.session.load();
            this.shortcuts.init();
            this.autoSave.init();
            this.addBeforeUnloadGuard();
            // Initialize shared MathLive virtual keyboard if available
            try {
                if (window.MathfieldElement && typeof MathfieldElement.makeSharedVirtualKeyboard === 'function') {
                    MathfieldElement.makeSharedVirtualKeyboard();
                }
            } catch {}
        },

        cacheDomElements() {
            const ids = {
                alertContainer: 'alertContainer', newSessionBtn: 'newSessionBtn',
                fileUpload: 'fileUpload', fileInput: 'fileInput', fileList: 'fileList',
                translateBtn: 'translateBtn', geminiKeyInput: 'geminiKey', chatgptKeyInput: 'chatgptKey',
                geminiKeyGroup: 'geminiKeyGroup', chatgptKeyGroup: 'chatgptKeyGroup',
                localModelGroup: 'localModelGroup', localModelUrl: 'localModelUrl', localModelName: 'localModelName',
                setupSection: 'setupSection', progressContainer: 'progressContainer', progressText: 'progressText',
                previewSection: 'previewSection', previewContainer: 'previewContainer', exportBtn: 'exportBtn',
                manageGlossaryBtn: 'manageGlossaryBtn', glossaryModal: 'glossaryModal',
                closeGlossaryModalBtn: 'closeGlossaryModalBtn', addGlossaryTermBtn: 'addGlossaryTermBtn',
                glossaryTermInput: 'glossaryTerm', glossaryTranslationInput: 'glossaryTranslation',
                glossaryListContainer: 'glossaryListContainer', useGlossaryCheckbox: 'useGlossaryCheckbox',
                themeToggle: 'theme-toggle', analyticsSection: 'analyticsSection',
                statsContainer: 'statsContainer', exportFormat: 'exportFormat',
                searchPreview: 'searchPreview', undoBtn: 'undoBtn', redoBtn: 'redoBtn',
                importGlossaryBtn: 'importGlossaryBtn', exportGlossaryBtn: 'exportGlossaryBtn',
                glossaryFileInput: 'glossaryFileInput', glossarySearch: 'glossarySearch',
                glossaryCategory: 'glossaryCategory',
                imageAnnotatorModal: 'imageAnnotatorModal',
                imageAnnotatorCanvas: 'imageAnnotatorCanvas',
                imageAnnotatorClose: 'imageAnnotatorClose',
                imageAnnotatorSave: 'imageAnnotatorSave',
                mappedIdsInput: 'mappedIdsInput', useMappedIdsCheckbox: 'useMappedIdsCheckbox',
                manageIdsBtn: 'manageIdsBtn', mappedIdsModal: 'mappedIdsModal',
                closeMappedIdsModalBtn: 'closeMappedIdsModalBtn',
                mappedIdsCount: 'mappedIdsCount', fetchMappedIdsBtn: 'fetchMappedIdsBtn',
                manageSubjectsBtn: 'manageSubjectsBtn', subjectsModal: 'subjectsModal',
                closeSubjectsModalBtn: 'closeSubjectsModalBtn', subjectSelect: 'subjectSelect',
                gradeSelect: 'gradeSelect', promptPreview: 'promptPreview', applyPromptBtn: 'applyPromptBtn',
                cancelTranslationBtn: 'cancelTranslationBtn', saveIndicator: 'saveIndicator',
                ephemeralKeysCheckbox: 'ephemeralKeysCheckbox',
                useTmCheckbox: 'useTmCheckbox', useProofreadCheckbox: 'useProofreadCheckbox'
            };
            for (const k in ids) this.dom[k] = document.getElementById(ids[k]);
            this.dom.apiProviderRadios = document.querySelectorAll('input[name="apiProvider"]');
        },
        
        bindEvents() {
            this.dom.newSessionBtn.addEventListener('click', this.session.clear.bind(this.session));
            this.dom.apiProviderRadios.forEach(radio => radio.addEventListener('change', this.events.onApiProviderChange.bind(this)));
            this.dom.fileUpload.addEventListener('click', () => this.dom.fileInput.click());
            this.dom.fileUpload.addEventListener('dragover', this.events.onDragOver);
            this.dom.fileUpload.addEventListener('dragleave', this.events.onDragLeave);
            this.dom.fileUpload.addEventListener('drop', this.events.onFileDrop.bind(this));
            this.dom.fileInput.addEventListener('change', this.events.onFileSelect.bind(this));
            this.dom.translateBtn.addEventListener('click', this.startTranslationProcess.bind(this));
            this.dom.cancelTranslationBtn.addEventListener('click', this.api.cancel.bind(this.api));
            this.dom.exportBtn.addEventListener('click', () => this.export.exportAs(this.dom.exportFormat.value));
            this.dom.geminiKeyInput.addEventListener('input', () => this.state.hasUnsavedChanges = true);
            this.dom.chatgptKeyInput.addEventListener('input', () => this.state.hasUnsavedChanges = true);
            this.dom.localModelUrl.addEventListener('input', () => this.state.hasUnsavedChanges = true);
            this.dom.localModelName.addEventListener('input', () => this.state.hasUnsavedChanges = true);
            this.dom.themeToggle.addEventListener('click', this.theme.toggle.bind(this.theme));
            this.dom.mappedIdsInput.addEventListener('input', () => this.state.hasUnsavedChanges = true);
            this.dom.useMappedIdsCheckbox.addEventListener('change', () => this.state.hasUnsavedChanges = true);
            this.dom.ephemeralKeysCheckbox.addEventListener('change', () => this.state.hasUnsavedChanges = true);
            this.dom.useTmCheckbox.addEventListener('change', () => this.state.hasUnsavedChanges = true);
            this.dom.useProofreadCheckbox.addEventListener('change', () => this.state.hasUnsavedChanges = true);
            
            this.dom.searchPreview.addEventListener('input', this.preview.filter.bind(this.preview));
            this.dom.undoBtn.addEventListener('click', this.history.undo.bind(this.history));
            this.dom.redoBtn.addEventListener('click', this.history.redo.bind(this.history));

            this.dom.manageGlossaryBtn.addEventListener('click', () => this.ui.showGlossaryModal(true));
            this.dom.closeGlossaryModalBtn.addEventListener('click', () => this.ui.showGlossaryModal(false));
            this.dom.addGlossaryTermBtn.addEventListener('click', this.glossary.add.bind(this.glossary));
            this.dom.exportGlossaryBtn.addEventListener('click', this.glossary.export.bind(this.glossary));
            this.dom.importGlossaryBtn.addEventListener('click', () => this.dom.glossaryFileInput.click());
            this.dom.glossaryFileInput.addEventListener('change', (e) => this.glossary.import(e.target.files[0]));
            this.dom.glossarySearch.addEventListener('input', (e) => this.glossary.filter(e.target.value));
            
            this.dom.manageIdsBtn.addEventListener('click', () => this.ui.showMappedIdsModal(true));
            this.dom.closeMappedIdsModalBtn.addEventListener('click', () => this.ui.showMappedIdsModal(false));
            this.dom.fetchMappedIdsBtn.addEventListener('click', this.mappedIds.fetch.bind(this.mappedIds));

            this.dom.manageSubjectsBtn.addEventListener('click', () => this.ui.showSubjectsModal(true));
            this.dom.closeSubjectsModalBtn.addEventListener('click', () => this.ui.showSubjectsModal(false));
            this.dom.subjectSelect.addEventListener('change', this.subjects.onSubjectChange.bind(this.subjects));
            this.dom.gradeSelect.addEventListener('change', this.subjects.onGradeChange.bind(this.subjects));
            this.dom.applyPromptBtn.addEventListener('click', this.subjects.apply.bind(this.subjects));

            // Image annotator events
            const openAnnotatorBtn = document.getElementById('openAnnotatorBtn');
            if (openAnnotatorBtn) openAnnotatorBtn.addEventListener('click', this.annotator.open.bind(this.annotator));
            this.dom.imageAnnotatorClose.addEventListener('click', this.annotator.close.bind(this.annotator));
            this.dom.imageAnnotatorSave.addEventListener('click', this.annotator.save.bind(this.annotator));

            // Event delegation for all preview field updates
            this.dom.previewContainer.addEventListener('input', (e) => {
                const fieldContainer = e.target.closest('.editable-preview-field');
                if (fieldContainer) {
                    this.preview.handlePreviewFieldUpdate(fieldContainer);
                }
            });
            // Ensure MathLive keyboard opens for inline chemistry/math on focus
            this.dom.previewContainer.addEventListener('pointerdown', (e) => {
                const mf = e.target && e.target.closest && e.target.closest('math-field');
                if (mf) {
                    try {
                        mf.removeAttribute('read-only');
                        mf.setAttribute('virtual-keyboard-mode', 'onfocus');
                        mf.setAttribute('use-shared-virtual-keyboard', '');
                        if (typeof mf.executeCommand === 'function') mf.executeCommand('showVirtualKeyboard');
                        mf.focus();
                        e.stopPropagation();
                    } catch {}
                }
            });
        },
        
        events: {
            onApiProviderChange(e) {
                const provider = e.target.value;
                TranslatorApp.dom.geminiKeyGroup.classList.toggle('hidden', provider !== 'gemini');
                TranslatorApp.dom.chatgptKeyGroup.classList.toggle('hidden', provider !== 'chatgpt');
                TranslatorApp.dom.localModelGroup.classList.toggle('hidden', provider !== 'local');
                TranslatorApp.state.hasUnsavedChanges = true;
            },
            onDragOver(e) { e.preventDefault(); e.currentTarget.classList.add('dragover'); },
            onDragLeave(e) { e.preventDefault(); e.currentTarget.classList.remove('dragover'); },
            onFileDrop(e) { e.preventDefault(); TranslatorApp.dom.fileUpload.classList.remove('dragover'); TranslatorApp.fileHandler.addFiles(e.dataTransfer.files); },
            onFileSelect(e) { TranslatorApp.fileHandler.addFiles(e.target.files); }
        },

        theme: {
            init() {
                const savedTheme = localStorage.getItem('translatorTheme') || 'light';
                this.set(savedTheme);
            },
            toggle() {
                const current = document.documentElement.getAttribute('data-theme');
                this.set(current === 'dark' ? 'light' : 'dark');
            },
            set(themeName) {
                document.documentElement.setAttribute('data-theme', themeName);
                localStorage.setItem('translatorTheme', themeName);
                TranslatorApp.dom.themeToggle.textContent = themeName === 'dark' ? 'â˜€ï¸' : 'ğŸŒ™';
            }
        },

        shortcuts: {
            init() {
                document.addEventListener('keydown', (e) => {
                    if (e.ctrlKey || e.metaKey) {
                        switch(e.key.toLowerCase()) {
                            case 's': e.preventDefault(); TranslatorApp.session.save(); TranslatorApp.ui.setSaveIndicator('saved'); break;
                            case 'o': e.preventDefault(); TranslatorApp.dom.fileInput.click(); break;
                            case 'enter':
                                if(TranslatorApp.state.activeScreen === 'setup') {
                                    e.preventDefault(); TranslatorApp.dom.translateBtn.click();
                                } break;
                            case 'z': e.preventDefault(); TranslatorApp.history.undo(); break;
                            case 'y': e.preventDefault(); TranslatorApp.history.redo(); break;
                        }
                    }
                });
            }
        },

        addBeforeUnloadGuard() {
            window.addEventListener('beforeunload', (e) => {
                if (TranslatorApp.state.hasUnsavedChanges) { e.preventDefault(); e.returnValue = ''; }
            });
        },

        utils: {
            collectAllTextsFromFiles(filesArr) {
                const bag = new Set();
                const toPlain = (html) => { 
                    if (typeof html !== 'string') return '';
                    const div = document.createElement('div'); 
                    div.innerHTML = html; 
                    return (div.textContent || div.innerText || '').trim(); 
                };

                const traverse = (obj) => {
                    if (!obj) return;
                    if (Array.isArray(obj)) {
                        obj.forEach(item => traverse(item));
                    } else if (typeof obj === 'object') {
                        Object.keys(obj).forEach(key => {
                            const value = obj[key];
                            // **IMPROVEMENT**: More specific keys to check for translatable content
                            const translatableKeys = ['stem', 'html_content', 'answer', 'statement'];
                            if (translatableKeys.includes(key) && typeof value === 'string') {
                                const plain = toPlain(value);
                                if (plain) bag.add(plain);
                            } else if (key === 'gap_text_keys' && Array.isArray(value)) {
                                value.forEach(item => {
                                    if(item && typeof item.value === 'string') {
                                        const plain = toPlain(item.value);
                                        if (plain) bag.add(plain);
                                    }
                                });
                            }
                            else {
                                traverse(value);
                            }
                        });
                    }
                };

                filesArr.forEach(f => {
                    if (f.data) traverse(f.data);
                });
                
                return Array.from(bag);
            },
            escapeRegex(str) { return str.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&'); }
        },

        remoteGlossary: {
            map: {},
            async fetchApproved(subject, texts) {
                this.map = {};
                if (!subject || subject === 'None') return this.map;
                try {
                    const tq = `select A,B where C = '${(subject || '').replace(/'/g, "\\'")}'`;
                    const url = `https://docs.google.com/spreadsheets/d/${GOOGLE_SHEET_ID}/gviz/tq?sheet=termbase&tqx=out:json&headers=1&tq=${encodeURIComponent(tq)}`;
                    const res = await fetch(url, { cache: 'no-cache' });
                    const raw = await res.text();
                    const match = raw.match(/google\.visualization\.Query\.setResponse\(([\s\S]+)\);/);
                    if (!match) throw new Error('ØªØ¹Ø°Ù‘Ø± Ù‚Ø±Ø§Ø¡Ø© Ø§Ø³ØªØ¬Ø§Ø¨Ø© gviz.');
                    const data = JSON.parse(match[1]);
                    const rows = data.table?.rows || [];
                    const allPairs = rows.map(r => ({
                        term: (r.c?.[0]?.v || '').toString().trim(),
                        translation: (r.c?.[1]?.v || '').toString().trim()
                    })).filter(x => x.term && x.translation);

                    const loweredTexts = Array.isArray(texts) ? texts.map(t => (t || '').toString().toLowerCase()) : [];
                    const map = {};
                    if (loweredTexts.length > 0) {
                        allPairs.forEach(({ term, translation }) => {
                            const tl = term.toLowerCase();
                            if (loweredTexts.some(tx => tx.includes(tl))) map[term] = translation;
                        });
                    } else {
                        allPairs.forEach(({ term, translation }) => { map[term] = translation; });
                    }
                    this.map = map;
                    return this.map;
                } catch (e) {
                    console.warn('GVIZ fetch failed:', e);
                    TranslatorApp.ui.showAlert('ØªØ¹Ø°Ù‘Ø± Ø¬Ù„Ø¨ Ø§Ù„Ù…ØµØ·Ù„Ø­Ø§Øª Ø§Ù„Ù…Ø¹ØªÙ…Ø¯Ø© (Ø³ÙŠØªÙ… Ø§Ù„Ø§Ø³ØªÙ…Ø±Ø§Ø± Ø¨Ø¯ÙˆÙ†Ù‡Ø§).', 'info', 4000);
                    this.map = {};
                    return this.map;
                }
            },
            applyWithPlaceholders(text) {
                if (!text || !this.map || Object.keys(this.map).length === 0) {
                    return { modifiedText: text, placeholders: {} };
                }
                let modifiedText = text;
                const placeholders = {};
                let i = 0;
                const terms = Object.keys(this.map).filter(Boolean).sort((a, b) => b.length - a.length);
                for (const term of terms) {
                    const translation = this.map[term];
                    if (!translation) continue;
                    const esc = TranslatorApp.utils.escapeRegex(term.trim());
                    const useWordBoundary = /^[A-Za-z0-9 _-]+$/.test(term);
                    const re = new RegExp(useWordBoundary ? `\\b${esc}\\b` : esc, 'gi');
                    if (re.test(modifiedText)) {
                        const ph = `__GLOSSARY_${i++}__`;
                        placeholders[ph] = translation;
                        modifiedText = modifiedText.replace(re, ph);
                    }
                }
                return { modifiedText, placeholders };
            },
            revertPlaceholders(text, placeholders) {
                if (!placeholders || !text) return text;
                let out = text;
                for (const [ph, tr] of Object.entries(placeholders)) out = out.split(ph).join(tr);
                return out;
            }
        },

                    security: {
                SALT: "a-secure-static-salt-for-obfuscation",
                encrypt(key) { try { return btoa(key + this.SALT); } catch { return ''; } },
                decrypt(encryptedKey) { try { const decoded = atob(encryptedKey); return decoded.endsWith(this.SALT) ? decoded.slice(0, -this.SALT.length) : ''; } catch { return ''; } },
                sanitize(html) {
                    if (typeof html !== 'string') return html;
                    if (window.DOMPurify) {
                        return DOMPurify.sanitize(html, {
                            ALLOWED_TAGS: ['b','i','u','em','strong','sub','sup','br','span','p','ul','ol','li','img','a','code','pre','table','tr','td','th','thead','tbody','math', 'div', 'math-field', 'audio'],
                            ALLOWED_ATTR: ['href','src','alt','title','class','style', 'dir', 'value', 'default-mode', 'data-path', 'data-file-index', 'data-blank', 'read-only', 'controls', 'virtual-keyboard-mode', 'use-shared-virtual-keyboard', 'data-node-type', 'data-node-variation']
                        });
                    }
                    return html.replace(/<script\b[^<]*(?:(?!<\/script>)<[^<]*)*<\/script>/gi, '');
                }
            },

                    quality: {
                wantsArabicIndicDigits(subject, grade) {
                    if (subject === 'Mathematics' && ['Grades 1â€“3','Grades 8â€“12'].includes(grade)) return true;
                    if (subject === 'Science' && grade === 'Grade 9') return true;
                    return false;
                },
                protectSegments(text) {
                    const placeholders = {};
                    let idx = 0;
                    const patterns = [
                        /<math-field[\s\S]*?<\/math-field>/g,
                        /<audio[\s\S]*?<\/audio>/g,
                        /<img[^>]*>/g,
                        // Don't protect tables - let their content be translated
                        // /<table[\s\S]*?<\/table>/g,
                        /_{3,}/g,
                        /```[\s\S]*?```/g,
                        /`[^`]*`/g,
                        /\$\$[\s\S]*?\$\$/g,
                        /\$[^$]*\$/g,
                        /\\\[[\s\S]*?\\]/g,
                        /\\\([\s\S]*?\\\)/g,
                        /https?:\/\/\S+/g,
                        // Protect Lexical theme elements that might interfere with translation
                        /<span[^>]*class="[^"]*LexicalTheme[^"]*"[^>]*>[\s\S]*?<\/span>/g,
                        /<p[^>]*class="[^"]*LexicalTheme[^"]*"[^>]*>[\s\S]*?<\/p>/g
                    ];
                    let protectedText = String(text || '');
                    for (const re of patterns) {
                        protectedText = protectedText.replace(re, (m) => { const ph = `__LOCK_${idx++}__`; placeholders[ph] = m; return ph; });
                    }
                    return { protectedText, placeholders };
                },
            restoreSegments(text, placeholders) {
                if (!placeholders) return text;
                let out = text || '';
                for (const [ph, val] of Object.entries(placeholders)) out = out.split(ph).join(val);
                return out;
            },
            convertDigits(str, toArabicIndic) {
                const en = '0123456789'.split(''); const ar = 'Ù Ù¡Ù¢Ù£Ù¤Ù¥Ù¦Ù§Ù¨Ù©'.split('');
                if (toArabicIndic) return (str || '').replace(/[0-9]/g, ch => ar[+ch]);
                return (str || '').replace(/[Ù -Ù©]/g, ch => en[ar.indexOf(ch)]);
            },
            normalizeArabicPunct(str) {
                return (str || '')
                    .replace(/ ,/g, 'ØŒ')
                    .replace(/, /g, 'ØŒ ')
                    .replace(/,/g, 'ØŒ')
                    .replace(/;/g, 'Ø›')
                    .replace(/\?/g, 'ØŸ')
                    .replace(/["â€œâ€]/g, 'Â»')
                    .replace(/'/g, 'Ê¼')
                    .replace(/\s+([ØŒØ›ØŸ])/g, '$1')
                    .replace(/([ØŒØ›])(?=[^\s])/g, '$1 ')
                    .replace(/\s+/g, ' ');
            },
            enforceUnits(str) {
                const map = { cm:'Ø³Ù…', mm:'Ù…Ù…', km:'ÙƒÙ…', m:'Ù…', kg:'ÙƒØ¬Ù…', g:'Ø¬Ù…', l:'Ù„', L:'Ù„', ml:'Ù…Ù„', s:'Ø«', min:'Ø¯', h:'Ø³' };
                return (str || '').replace(/(\d[0-9Ù -Ù©.,]*)\s*(cm|mm|km|m|kg|g|l|L|ml|s|min|h)\b/g, (m, num, u) => `${num}\u00A0${map[u] || u}`);
            },
            postProcess(text, ctx = { subject:'None', grade:'None' }) {
                let out = text || '';
                const toArabic = this.wantsArabicIndicDigits(ctx.subject, ctx.grade);
                out = this.convertDigits(out, toArabic);
                out = this.enforceUnits(out);
                out = this.normalizeArabicPunct(out);
                out = out.replace(/Â»([^Â»Â«]+)Â»/g, 'Â«$1Â»');
                return out;
            },
            qa: {
                extractPlain(html) { const div = document.createElement('div'); div.innerHTML = html || ''; return (div.textContent || div.innerText || '').trim(); },
                unifyDigits(s) { const ar='Ù Ù¡Ù¢Ù£Ù¤Ù¥Ù¦Ù§Ù¨Ù©'; return (s||'').replace(/[Ù -Ù©]/g, d => String(ar.indexOf(d))); },
                extractNumbers(s) { return Array.from((s || '').matchAll(/[0-9Ù -Ù©]+(?:[.,][0-9Ù -Ù©]+)?/g)).map(m => m[0]); },
                sameNumberSet(srcArr, dstArr) {
                    const a = srcArr.map(this.unifyDigits).sort().join('|');
                    const b = dstArr.map(this.unifyDigits).sort().join('|');
                    return a === b;
                },
                checkNumbers(srcHtml, dstHtml) {
                    const s = this.extractPlain(srcHtml); const d = this.extractPlain(dstHtml);
                    const srcNums = this.extractNumbers(s); const dstNums = this.extractNumbers(d);
                    return this.sameNumberSet(srcNums, dstNums) ? [] : [`ØªØ­Ø°ÙŠØ±: ØªØºÙŠØ±Øª/Ø§Ø®ØªÙØª Ø£Ø±Ù‚Ø§Ù… (${srcNums.join(',')}) â†’ (${dstNums.join(',')}).`];
                },
                checkSeparator(dstText, sep) {
                    if (!dstText) return [];
                    const want = (dstText.match(new RegExp(sep.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&'), 'g')) || []).length;
                    const legacy = (dstText.match(/<SEP>/g) || []).length;
                    if (legacy > 0 && want === 0) return ['ØªØ­Ø°ÙŠØ±: Ù„Ù… ÙŠÙØ­ÙØ¸ Ø§Ù„ÙØ§ØµÙ„ <SEP> ÙƒÙ…Ø§ Ù‡Ùˆ.'];
                    return [];
                },
                checkHtmlBalance(dstHtml) {
                    const tags = ['b','i','u','strong','em','sub','sup','span','p','ul','ol','li'];
                    const errs = [];
                    tags.forEach(t => {
                        const open = (dstHtml.match(new RegExp(`<${t}\\b`, 'gi')) || []).length;
                        const close = (dstHtml.match(new RegExp(`</${t}>`, 'gi')) || []).length;
                        if (open !== close) errs.push(`ØªØ­Ø°ÙŠØ±: Ø§Ù„ÙˆØ³Ù… <${t}> ØºÙŠØ± Ù…ØªÙˆØ§Ø²Ù† (${open}/${close}).`);
                    });
                    return errs;
                }
            }
        },

        tm: {
            KEY: 'translatorTMv1',
            getStore() { try { return JSON.parse(localStorage.getItem(this.KEY) || '{}'); } catch { return {}; } },
            saveStore(obj) { localStorage.setItem(this.KEY, JSON.stringify(obj)); },
            plain(html) { const div = document.createElement('div'); div.innerHTML = html || ''; return (div.textContent || div.innerText || '').trim().toLowerCase(); },
            key(text, ctx) { return `${ctx.subject}||${ctx.grade}||${this.plain(text)}`; },
            get(text, ctx) { const store = this.getStore(); return store[this.key(text, ctx)] || null; },
            put(text, ctx, translated) {
                const store = this.getStore();
                const k = this.key(text, ctx);
                store[k] = translated;
                this.saveStore(store);
            }
        },

        session: {
            save() {
                const ephemeral = TranslatorApp.dom.ephemeralKeysCheckbox.checked;
                const sessionData = {
                    apiKeys: ephemeral ? null : {
                        gemini: TranslatorApp.security.encrypt(TranslatorApp.dom.geminiKeyInput.value),
                        chatgpt: TranslatorApp.security.encrypt(TranslatorApp.dom.chatgptKeyInput.value),
                    },
                    localModelUrl: TranslatorApp.dom.localModelUrl.value,
                    localModelName: TranslatorApp.dom.localModelName.value,
                    selectedProvider: document.querySelector('input[name="apiProvider"]:checked').value,
                    selectedFilesInfo: TranslatorApp.state.selectedFilesInfo,
                    originalJsonData: TranslatorApp.state.originalJsonData,
                    translatedJsonData: TranslatorApp.state.translatedJsonData,
                    glossary: TranslatorApp.state.glossary,
                    activeScreen: TranslatorApp.state.activeScreen,
                    mappedIds: TranslatorApp.dom.mappedIdsInput.value,
                    useMappedIds: TranslatorApp.dom.useMappedIdsCheckbox.checked,
                    selectedSubject: TranslatorApp.state.selectedSubject,
                    selectedGrade: TranslatorApp.state.selectedGrade,
                    ephemeralKeys: ephemeral,
                    useTM: TranslatorApp.dom.useTmCheckbox.checked,
                    useProofread: TranslatorApp.dom.useProofreadCheckbox.checked
                };
                localStorage.setItem('translatorSession', JSON.stringify(sessionData));
                // Always save API keys to sessionStorage for persistence across browser sessions
                if (TranslatorApp.dom.geminiKeyInput.value || TranslatorApp.dom.chatgptKeyInput.value) {
                    sessionStorage.setItem('translatorPersistentKeys', JSON.stringify({
                        gemini: TranslatorApp.security.encrypt(TranslatorApp.dom.geminiKeyInput.value),
                        chatgpt: TranslatorApp.security.encrypt(TranslatorApp.dom.chatgptKeyInput.value),
                        provider: document.querySelector('input[name="apiProvider"]:checked').value
                    }));
                }
                if (ephemeral) {
                    sessionStorage.setItem('translatorEphemeralKeys', JSON.stringify({
                        gemini: TranslatorApp.security.encrypt(TranslatorApp.dom.geminiKeyInput.value),
                        chatgpt: TranslatorApp.security.encrypt(TranslatorApp.dom.chatgptKeyInput.value)
                    }));
                } else {
                    sessionStorage.removeItem('translatorEphemeralKeys');
                }
                TranslatorApp.state.hasUnsavedChanges = false;
            },
            load() {
                const saved = localStorage.getItem('translatorSession');
                if (!saved) return;
                try {
                    const s = JSON.parse(saved);
                    TranslatorApp.dom.ephemeralKeysCheckbox.checked = !!s.ephemeralKeys;
                    
                    // Load API keys with fallback to persistent storage
                    let keysLoaded = false;
                    if (s.apiKeys && !s.ephemeralKeys) {
                        TranslatorApp.dom.geminiKeyInput.value = TranslatorApp.security.decrypt(s.apiKeys?.gemini || '');
                        TranslatorApp.dom.chatgptKeyInput.value = TranslatorApp.security.decrypt(s.apiKeys?.chatgpt || '');
                        keysLoaded = true;
                    } else if (s.ephemeralKeys) {
                        const sk = JSON.parse(sessionStorage.getItem('translatorEphemeralKeys') || '{}');
                        TranslatorApp.dom.geminiKeyInput.value = TranslatorApp.security.decrypt(sk?.gemini || '');
                        TranslatorApp.dom.chatgptKeyInput.value = TranslatorApp.security.decrypt(sk?.chatgpt || '');
                        keysLoaded = true;
                    }
                    
                    // Fallback to persistent keys if no keys loaded from session
                    if (!keysLoaded) {
                        const persistentKeys = JSON.parse(sessionStorage.getItem('translatorPersistentKeys') || '{}');
                        if (persistentKeys.gemini || persistentKeys.chatgpt) {
                            TranslatorApp.dom.geminiKeyInput.value = TranslatorApp.security.decrypt(persistentKeys.gemini || '');
                            TranslatorApp.dom.chatgptKeyInput.value = TranslatorApp.security.decrypt(persistentKeys.chatgpt || '');
                            if (persistentKeys.provider) {
                                const radio = document.querySelector(`input[name="apiProvider"][value="${persistentKeys.provider}"]`);
                                if (radio) { radio.checked = true; TranslatorApp.events.onApiProviderChange({ target: { value: persistentKeys.provider } }); }
                            }
                        }
                    }
                    
                    TranslatorApp.dom.localModelUrl.value = s.localModelUrl || 'http://localhost:11434/api/generate';
                    TranslatorApp.dom.localModelName.value = s.localModelName || 'gemma:7b';
                    TranslatorApp.state.selectedFilesInfo = s.selectedFilesInfo || [];
                    TranslatorApp.state.originalJsonData = s.originalJsonData || [];
                    TranslatorApp.state.translatedJsonData = s.translatedJsonData || [];
                    TranslatorApp.state.glossary = s.glossary || [];
                    TranslatorApp.state.activeScreen = s.activeScreen || 'setup';
                    TranslatorApp.dom.mappedIdsInput.value = s.mappedIds || '[]';
                    TranslatorApp.dom.useMappedIdsCheckbox.checked = s.useMappedIds || false;
                    TranslatorApp.state.selectedSubject = s.selectedSubject || 'None';
                    TranslatorApp.state.selectedGrade = s.selectedGrade || 'None';
                    TranslatorApp.dom.useTmCheckbox.checked = s.useTM ?? true;
                    TranslatorApp.dom.useProofreadCheckbox.checked = s.useProofread ?? false;

                    if (s.selectedProvider && !keysLoaded) {
                        const radio = document.querySelector(`input[name="apiProvider"][value="${s.selectedProvider}"]`);
                        if (radio) { radio.checked = true; TranslatorApp.events.onApiProviderChange({ target: { value: s.selectedProvider } }); }
                    }
                    TranslatorApp.ui.renderFileList();
                    TranslatorApp.glossary.render();
                    TranslatorApp.subjects.updateUI();
                    if (TranslatorApp.state.activeScreen === 'preview' && TranslatorApp.state.translatedJsonData.length > 0) {
                        TranslatorApp.ui.showScreen('preview');
                        TranslatorApp.preview.render();
                        const stats = TranslatorApp.statistics.calculate();
                        TranslatorApp.ui.renderStatistics(stats);
                        TranslatorApp.history.push(TranslatorApp.state.translatedJsonData);
                    } else {
                        TranslatorApp.ui.showScreen('setup');
                    }
                    TranslatorApp.ui.showAlert('ØªÙ… Ø§Ø³ØªØ¹Ø§Ø¯Ø© Ø§Ù„Ø¬Ù„Ø³Ø© Ø§Ù„Ø³Ø§Ø¨Ù‚Ø© Ø¨Ù†Ø¬Ø§Ø­.', 'success');
                } catch (e) {
                    console.error('Ø®Ø·Ø£ ÙÙŠ Ø§Ø³ØªØ¹Ø§Ø¯Ø© Ø§Ù„Ø¬Ù„Ø³Ø©:', e);
                    TranslatorApp.ui.showAlert('Ø­Ø¯Ø« Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ Ø§Ø³ØªØ¹Ø§Ø¯Ø© Ø§Ù„Ø¬Ù„Ø³Ø© Ø§Ù„Ø³Ø§Ø¨Ù‚Ø©.', 'error');
                }
            },
            clear() {
                const btn = TranslatorApp.dom.newSessionBtn;
                if (btn.dataset.confirm === 'true') {
                    localStorage.removeItem('translatorSession');
                    sessionStorage.removeItem('translatorEphemeralKeys');
                    // Keep persistent API keys unless user explicitly wants to clear everything
                    // sessionStorage.removeItem('translatorPersistentKeys');
                    location.reload();
                } else {
                    btn.dataset.confirm = 'true';
                    btn.textContent = 'Ù‡Ù„ Ø£Ù†Øª Ù…ØªØ£ÙƒØ¯ØŸ Ø§Ù†Ù‚Ø± Ù…Ø¬Ø¯Ø¯Ø§Ù‹';
                    btn.classList.add('bg-yellow-500', 'hover:bg-yellow-600');
                    btn.classList.remove('bg-red-500', 'hover:bg-red-600');
                    setTimeout(() => {
                        btn.dataset.confirm = 'false';
                        btn.textContent = 'Ø¨Ø¯Ø¡ Ø¬Ù„Ø³Ø© Ø¬Ø¯ÙŠØ¯Ø©';
                        btn.classList.remove('bg-yellow-500', 'hover:bg-yellow-600');
                        btn.classList.add('bg-red-500', 'hover:bg-red-600');
                    }, 3000);
                }
            }
        },
        
        autoSave: {
            init() {
                setInterval(() => {
                    if (TranslatorApp.state.hasUnsavedChanges) {
                        TranslatorApp.session.save();
                        TranslatorApp.ui.setSaveIndicator('saving');
                        setTimeout(() => TranslatorApp.ui.setSaveIndicator('saved'), 400);
                    }
                }, 8000);
            }
        },

        validation: {
            validateJsonStructure(data, fileName) {
                if (typeof data !== 'object' || !data.hasOwnProperty('parts')) {
                     throw new Error(`Ù…Ù„Ù ${fileName} ÙŠÙØªÙ‚Ø¯ Ù„Ù„Ø­Ù‚Ù„ Ø§Ù„Ù…Ø·Ù„ÙˆØ¨ (parts).`);
                }
                return true;
            },
            validateApiKey(key, provider) {
                if (!key) return false;
                if (provider === 'gemini') return key.startsWith('AIza') && key.length > 30;
                if (provider === 'chatgpt') return key.startsWith('sk-') && key.length >= 20;
                return false;
            }
        },

        fileHandler: {
            addFiles(files) {
                const incoming = Array.from(files).filter(f => f && (f.type === 'application/json' || f.name.toLowerCase().endsWith('.json')));
                incoming.forEach(file => {
                    TranslatorApp.state.fileStore.set(file.name, file);
                    if (!TranslatorApp.state.selectedFilesInfo.some(f => f.name === file.name)) {
                        TranslatorApp.state.selectedFilesInfo.push({ name: file.name, size: file.size });
                    } else {
                        const idx = TranslatorApp.state.selectedFilesInfo.findIndex(f => f.name === file.name);
                        if (idx > -1) TranslatorApp.state.selectedFilesInfo[idx].size = file.size;
                    }
                });
                TranslatorApp.ui.renderFileList();
                TranslatorApp.state.hasUnsavedChanges = true;
            },
            removeFile(index) {
                const info = TranslatorApp.state.selectedFilesInfo[index]; if (!info) return;
                const name = info.name;
                TranslatorApp.state.selectedFilesInfo.splice(index, 1);
                if (TranslatorApp.state.fileStore.has(name)) TranslatorApp.state.fileStore.delete(name);
                const origIdx = TranslatorApp.state.originalJsonData.findIndex(d => d.name === name);
                if (origIdx > -1) TranslatorApp.state.originalJsonData.splice(origIdx, 1);
                const transIdx = TranslatorApp.state.translatedJsonData.findIndex(d => d.name === name);
                if (transIdx > -1) TranslatorApp.state.translatedJsonData.splice(transIdx, 1);
                TranslatorApp.ui.renderFileList();
                TranslatorApp.state.hasUnsavedChanges = true;
            },
            async readFilesFromInput() {
                if (TranslatorApp.state.selectedFilesInfo.length === 0) throw new Error("Ù„Ø§ ØªÙˆØ¬Ø¯ Ù…Ù„ÙØ§Øª Ù…Ø­Ø¯Ø¯Ø©.");
                TranslatorApp.state.originalJsonData = [];
                const inputFiles = Array.from(TranslatorApp.dom.fileInput.files || []);
                for (const { name } of TranslatorApp.state.selectedFilesInfo) {
                    const file = TranslatorApp.state.fileStore.get(name) || inputFiles.find(f => f.name === name);
                    if (!file) throw new Error(`Ù„Ù… ÙŠØªÙ… Ø§Ù„Ø¹Ø«ÙˆØ± Ø¹Ù„Ù‰ Ø§Ù„Ù…Ù„Ù ${name}. ÙŠØ±Ø¬Ù‰ Ø¥Ø¹Ø§Ø¯Ø© ØªØ­Ø¯ÙŠØ¯Ù‡.`);
                    const content = await file.text();
                    const jsonData = JSON.parse(content);
                    TranslatorApp.validation.validateJsonStructure(jsonData, name);
                    TranslatorApp.state.originalJsonData.push({ name, data: jsonData });
                }
            }
        },
        
        mappedIds: {
            async fetch() {
                const count = TranslatorApp.dom.mappedIdsCount.value;
                if (!count || count <= 0) return TranslatorApp.ui.showAlert('Ø§Ù„Ø±Ø¬Ø§Ø¡ Ø¥Ø¯Ø®Ø§Ù„ Ø¹Ø¯Ø¯ ØµØ­ÙŠØ­.', 'error');
                const url = `https://12digit.nagwa.com/get.bulk.codes/${count}/cps/cps.system/`;
                TranslatorApp.ui.showAlert(`Ø¬Ø§Ø±ÙŠ Ø¬Ù„Ø¨ ${count} ÙƒÙˆØ¯...`, 'info', 3000);
                try {
                    const response = await fetch(url);
                    if (!response.ok) throw new Error(`ÙØ´Ù„ Ø§Ù„Ø·Ù„Ø¨. Ø­Ø§Ù„Ø© Ø§Ù„Ø®Ø§Ø¯Ù…: ${response.status}`);
                    const data = await response.json();
                    if (Array.isArray(data)) {
                        TranslatorApp.dom.mappedIdsInput.value = JSON.stringify(data, null, 2);
                        TranslatorApp.ui.showAlert('ØªÙ… Ø¬Ù„Ø¨ Ø§Ù„Ø£ÙƒÙˆØ§Ø¯ Ø¨Ù†Ø¬Ø§Ø­.', 'success');
                        TranslatorApp.state.hasUnsavedChanges = true;
                    } else {
                        throw new Error('Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ù„ÙŠØ³Øª Ù…ØµÙÙˆÙØ©.');
                    }
                } catch (error) {
                    console.error("Fetch Mapped IDs Error:", error);
                    TranslatorApp.ui.showAlert(`ÙØ´Ù„ Ø§Ù„Ø¬Ù„Ø¨ Ø¨Ø³Ø¨Ø¨ Ù‚ÙŠÙˆØ¯ CORS. Ø³ÙŠØªÙ… ÙØªØ­ Ø§Ù„Ø±Ø§Ø¨Ø· Ù„Ù„Ù†Ø³Ø® Ø§Ù„ÙŠØ¯ÙˆÙŠ.`, 'error', 8000);
                    window.open(url, '_blank');
                }
            }
        },

        glossary: {
            add() {
                const term = TranslatorApp.dom.glossaryTermInput.value.trim();
                const translation = TranslatorApp.dom.glossaryTranslationInput.value.trim();
                if (!term || !translation) return TranslatorApp.ui.showAlert('ÙŠØ±Ø¬Ù‰ Ø¥Ø¯Ø®Ø§Ù„ Ø§Ù„Ù…ØµØ·Ù„Ø­ ÙˆØªØ±Ø¬Ù…ØªÙ‡.', 'error');
                if (TranslatorApp.state.glossary.some(e => e.term.toLowerCase() === term.toLowerCase())) return TranslatorApp.ui.showAlert('Ø§Ù„Ù…ØµØ·Ù„Ø­ Ù…ÙˆØ¬ÙˆØ¯ Ø¨Ø§Ù„ÙØ¹Ù„.', 'error');
                TranslatorApp.state.glossary.push({ term, translation, category: TranslatorApp.dom.glossaryCategory.value, dateAdded: new Date().toISOString() });
                TranslatorApp.dom.glossaryTermInput.value = '';
                TranslatorApp.dom.glossaryTranslationInput.value = '';
                this.render();
                TranslatorApp.state.hasUnsavedChanges = true;
            },
            delete(index) { TranslatorApp.state.glossary.splice(index, 1); this.render(); TranslatorApp.state.hasUnsavedChanges = true; },
            render(filteredList = null) { const list = filteredList || TranslatorApp.state.glossary; TranslatorApp.ui.renderGlossaryList(list); },
            filter(searchTerm) {
                const term = searchTerm.toLowerCase();
                const filtered = TranslatorApp.state.glossary.filter(entry => entry.term.toLowerCase().includes(term) || entry.translation.toLowerCase().includes(term));
                this.render(filtered);
            },
            export() {
                if (TranslatorApp.state.glossary.length === 0) return TranslatorApp.ui.showAlert('Ø§Ù„Ù‚Ø§Ù…ÙˆØ³ ÙØ§Ø±Øº.', 'error');
                const escapeCSV = (str) => `"${(str || '').toString().replace(/"/g, '""')}"`;
                let csvContent = '\uFEFF"term","translation"\r\n';
                TranslatorApp.state.glossary.forEach(entry => { csvContent += `${escapeCSV(entry.term)},${escapeCSV(entry.translation)}\r\n`; });
                const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a'); a.href = url; a.download = 'translator_glossary.csv';
                document.body.appendChild(a); a.click(); document.body.removeChild(a); URL.revokeObjectURL(url);
                TranslatorApp.ui.showAlert('ØªÙ… ØªØµØ¯ÙŠØ± Ø§Ù„Ù‚Ø§Ù…ÙˆØ³ Ø¨Ù†Ø¬Ø§Ø­.', 'success');
            },
            async import(file) {
                if (!file) return;
                try {
                    const text = await file.text();
                    let imported = [];
                    const normalizeHeader = (h) => (h || '').toString().trim().replace(/^"|"$/g, '').toLowerCase();
                    const parseCsvLine = (line) => { const out = [], re = /("([^"]|"")*"|[^,]*)(,|$)/g; let m; while ((m = re.exec(line)) !== null) { let cell = (m[1] || '').replace(/^"|"$/g, '').replace(/""/g, '"'); out.push(cell); if (!m[3]) break; } return out; };
                    const isCsv = file.name.toLowerCase().endsWith('.csv') || /,/.test(text.split(/\r?\n/)[0] || '');
                    if (isCsv) {
                        const lines = text.split(/\r?\n/).filter(l => l.trim()); if (lines.length < 2) throw new Error('CSV ÙØ§Ø±Øº.');
                        const headerCells = parseCsvLine(lines[0]).map(normalizeHeader);
                        const termIdx = headerCells.findIndex(h => ['term','source term','Ù…ØµØ·Ù„Ø­'].includes(h));
                        const transIdx = headerCells.findIndex(h => ['translation','translated term','ØªØ±Ø¬Ù…Ø©'].includes(h));
                        if (termIdx === -1 || transIdx === -1) throw new Error('CSV ÙŠØ¬Ø¨ Ø£Ù† ÙŠØ­ØªÙˆÙŠ Ø£Ø¹Ù…Ø¯Ø© term Ùˆ translation.');
                        imported = lines.slice(1).map(line => {
                            const cells = parseCsvLine(line);
                            const term = (cells[termIdx] || '').trim();
                            const translation = (cells[transIdx] || '').trim();
                            return { term, translation };
                        }).filter(r => r.term && r.translation);
                    } else {
                        const raw = JSON.parse(text);
                        if (!Array.isArray(raw)) throw new Error('JSON ØºÙŠØ± ØµØ§Ù„Ø­.');
                        imported = raw.map(row => {
                            const term = (row.term || row['source term'] || row['Ù…ØµØ·Ù„Ø­'] || '').toString().trim();
                            const translation = (row.translation || row['translated term'] || row['ØªØ±Ø¬Ù…Ø©'] || '').toString().trim();
                            return { term, translation };
                        }).filter(r => r.term && r.translation);
                    }
                    const newEntries = imported.filter(newEntry => !TranslatorApp.state.glossary.some(existing => existing.term.toLowerCase().trim() === newEntry.term.toLowerCase().trim()))
                                                .map(e => ({ term: e.term, translation: e.translation, category: 'general', dateAdded: new Date().toISOString() }));
                    TranslatorApp.state.glossary = [...TranslatorApp.state.glossary, ...newEntries];
                    this.render();
                    TranslatorApp.state.hasUnsavedChanges = true;
                    TranslatorApp.ui.showAlert(`ØªÙ… Ø§Ø³ØªÙŠØ±Ø§Ø¯ ${newEntries.length} Ù…ØµØ·Ù„Ø­.`, 'success');
                } catch (e) {
                    console.error(e);
                    TranslatorApp.ui.showAlert('ÙØ´Ù„ Ø§Ø³ØªÙŠØ±Ø§Ø¯ Ø§Ù„Ù‚Ø§Ù…ÙˆØ³.', 'error');
                } finally { TranslatorApp.dom.glossaryFileInput.value = ''; }
            }
        },
        
        subjects: {
            data: {
                'None': { grades: ['None'], prompt: 'Translate to Arabic accurately. Preserve HTML/LaTeX and special placeholders (e.g., __LOCK_0__, __GLOSSARY_0__). If a text contains the separator \\n<SEP>\\n, translate each segment separately and preserve the separator exactly.' },
                'Mathematics': { grades: ['Grades 1â€“3','Grades 4â€“7','Grades 8â€“12'], prompts: {
                    'Grades 1â€“3': 'Task: Translate English Math questions for grades 1-3 into accurate, age-appropriate Arabic.\nRules:\n1) Use official MoE phrasing.\n2) Use Arabic-Indic numerals.\n3) Write equations in LaTeX. Transliterate variables to Arabic (Ø³ØŒ ØµØŒ Ø¹).\n4) Fractions as \\dfrac{Ø§Ù„Ø¨Ø³Ø·}{Ø§Ù„Ù…Ù‚Ø§Ù…}.\n5) If text contains \\n<SEP>\\n, translate each part and preserve separator.',
                    'Grades 4â€“7': 'Task: Translate English Math questions for grades 4-7 into accurate Arabic.\nRules:\n1) Use official MoE phrasing.\n2) Use English numerals.\n3) Translate units to Arabic abbreviations (cmâ†’Ø³Ù…).\n4) Fractions as \\dfrac{numerator}{denominator}.\n5) If text contains \\n<SEP>\\n, translate each part and preserve separator.',
                    'Grades 8â€“12': 'Task: Translate English Math questions for grades 8-12 into accurate Arabic.\nRules:\n1) Use official MoE phrasing.\n2) Use Arabic-Indic numerals; transliterate variables to Arabic.\n3) Fractions as \\dfrac{Ø§Ù„Ø¨Ø³Ø·}{Ø§Ù„Ù…Ù‚Ø§Ù…}.\n4) If text contains \\n<SEP>\\n, translate each part and preserve separator.'
                }},
                'Physics': { grades: ['Grades 10â€“12'], prompts: {
                    'Grades 10â€“12': 'Translate Physics questions.\nRules:\n1) Use official MoE phrasing.\n2) Use English numerals.\n3) Keep physical formulas (e.g., F=ma), variables, and units (cm, m, kg) in their original LTR format. Wrap formulas in `<span dir="ltr"></span>`.\n4) Keep subscripts and variables exact.\n5) If text contains \\n<SEP>\\n, translate parts separately and preserve separator.'
                }},
                'Chemistry': { grades: ['Grades 10â€“12'], prompts: {
                    'Grades 10â€“12': 'Translate Chemistry questions.\nRules:\n1) Use English numerals.\n2) Keep chemical formulas, symbols, and equations in their original LTR format. Wrap them in `<span dir="ltr"></span>` to ensure correct directionality.\n3) Keep units in English abbreviations.\n4) If text contains \\n<SEP>\\n, preserve separator.'
                }},
                'Biology': { grades: ['Grades 10â€“12'], prompts: {
                    'Grades 10â€“12': 'Translate Biology questions.\nUse English numerals; Arabic labels (Ø£ØŒ Ø¨ØŒ Ø¬); translate text within figures; preserve \\n<SEP>\\n.'
                }},
                'Science': { grades: ['Grades 4â€“8','Grade 9'], prompts: {
                    'Grades 4â€“8': 'Translate Science (4â€“8).\nUse English numerals; Arabic labels; chemical symbols in English; preserve \\n<SEP>\\n.',
                    'Grade 9': 'Translate Science (9).\nUse Arabic-Indic numerals; Arabic labels; preserve \\n<SEP>\\n.'
                }},
                'Integrated Science': { grades: ['Grades 10â€“12'], prompts: {
                    'Grades 10â€“12': 'Translate Integrated Science.\nUse English numerals; Arabic labels; keep units; preserve \\n<SEP>\\n.'
                }},
                'ICT': { grades: ['Grade 4','Grade 5'], prompts: {
                    'Grade 4': 'Translate ICT (Grade 4).\nUse Arabic-Indic numerals; product names bilingual; preserve \\n<SEP>\\n.',
                    'Grade 5': 'Translate ICT (Grade 5).\nUse English numerals; Arabic labels; preserve \\n<SEP>\\n.'
                }}
            },
            init() { this.populateSubjects(); this.updateUI(); },
            populateSubjects() {
                TranslatorApp.dom.subjectSelect.innerHTML = '';
                Object.keys(this.data).forEach(subject => {
                    const opt = document.createElement('option'); opt.value = subject; opt.textContent = subject;
                    TranslatorApp.dom.subjectSelect.appendChild(opt);
                });
            },
            populateGrades(subject) {
                TranslatorApp.dom.gradeSelect.innerHTML = '';
                const subjectData = this.data[subject];
                if (subjectData && subjectData.grades) subjectData.grades.forEach(grade => {
                    const opt = document.createElement('option'); opt.value = grade; opt.textContent = grade;
                    TranslatorApp.dom.gradeSelect.appendChild(opt);
                });
            },
            onSubjectChange() { const s = TranslatorApp.dom.subjectSelect.value; this.populateGrades(s); this.updatePromptPreview(); },
            onGradeChange() { this.updatePromptPreview(); },
            updatePromptPreview() { TranslatorApp.dom.promptPreview.value = this.buildSystemPrompt(); },
            getCurrentPrompt() {
                const subject = TranslatorApp.dom.subjectSelect.value;
                const grade = TranslatorApp.dom.gradeSelect.value;
                if (subject === 'None' || !this.data[subject]) return this.data['None'].prompt;
                return this.data[subject].prompts?.[grade] || Object.values(this.data[subject].prompts)[0] || '';
            },
            buildSystemPrompt() {
                const base = this.getCurrentPrompt();
                const subject = TranslatorApp.dom.subjectSelect.value;
                const grade = TranslatorApp.dom.gradeSelect.value;
                const wantArabic = TranslatorApp.quality.wantsArabicIndicDigits(subject, grade);
                const digitsRule = wantArabic ? 'Use Arabic-Indic numerals (Ù Ù¡Ù¢Ù£Ù¤Ù¥Ù¦Ù§Ù¨Ù©).' : 'Use English numerals (0123456789).';
                const core = [
                    'Core rules:',
                    '- Do NOT add or remove content.',
                    '- Translate text content inside of HTML tags. Preserve the HTML tags themselves (e.g., <table>, <b>, <img>) and all LaTeX markup exactly as-is.',
                    '- If present, keep placeholders __LOCK_n__ and __GLOSSARY_n__ unchanged.',
                    `- ${digitsRule}`,
                    `- If text contains the separator ${TranslatorApp.constants.CONTEXT_SEPARATOR}, translate each segment and preserve the separator exactly.`,
                    '- Keep the order of choices unchanged.',
                    '- Output in Arabic (MSA), formal tone.'
                ].join('\n');
                return `${base}\n\n${core}`;
            },
            async apply() {
                TranslatorApp.state.selectedSubject = TranslatorApp.dom.subjectSelect.value;
                TranslatorApp.state.selectedGrade = TranslatorApp.dom.gradeSelect.value;
                TranslatorApp.state.hasUnsavedChanges = true;
                TranslatorApp.ui.showSubjectsModal(false);
                TranslatorApp.ui.showAlert(`ØªÙ… ØªØ·Ø¨ÙŠÙ‚: ${TranslatorApp.state.selectedSubject} - ${TranslatorApp.state.selectedGrade}`, 'success');
            },
            updateUI() {
                TranslatorApp.dom.subjectSelect.value = TranslatorApp.state.selectedSubject;
                this.populateGrades(TranslatorApp.state.selectedSubject);
                TranslatorApp.dom.gradeSelect.value = TranslatorApp.state.selectedGrade;
                this.updatePromptPreview();
            }
        },

        api: {
            abortController: null,
            createAbortController() { if (this.abortController) this.abortController.abort(); this.abortController = new AbortController(); return this.abortController; },
            cancel() { if (this.abortController) { this.abortController.abort(); TranslatorApp.ui.showAlert('ØªÙ… Ø¥Ù„ØºØ§Ø¡ Ø¹Ù…Ù„ÙŠØ© Ø§Ù„ØªØ±Ø¬Ù…Ø©.', 'info'); TranslatorApp.state.isTranslating = false; TranslatorApp.ui.showScreen('setup'); } },

            async translateInChunks(jobs, apiKeyOrUrl, provider, localModelName = '', systemPrompt = '') {
                const CHUNK_SIZE = TranslatorApp.constants.CHUNK_SIZE;
                const total = jobs.length;
                let done = 0;
                jobs.forEach((job, idx) => job.uid = idx);

                for (let i = 0; i < jobs.length; i += CHUNK_SIZE) {
                    const chunk = jobs.slice(i, i + CHUNK_SIZE);
                    const items = chunk.map(j => ({ id: j.uid, text: j.originalText }));
                    TranslatorApp.ui.updateProgress(`Ø¬Ø§Ø±ÙŠ Ø§Ù„ØªØ±Ø¬Ù…Ø©... (${Math.min(done + items.length, total)}/${total})`);
                    const outItems = await this.translateItemsBatch(items, apiKeyOrUrl, provider, localModelName, systemPrompt);
                    outItems.forEach(obj => {
                        const job = chunk.find(j => j.uid === obj.id);
                        if (!job) return;
                        TranslatorApp.state.translationCache.set(job.originalText, (obj.text || '').toString().trim());
                    });
                    done += items.length;
                }
            },

            async translateItemsBatch(items, apiKeyOrUrl, provider, localModelName = '', systemPrompt = '') {
                const CONTEXT_SEPARATOR = TranslatorApp.constants.CONTEXT_SEPARATOR;
                const userInstruction = `Translate all provided text to Modern Standard Arabic. Preserve HTML/LaTeX and placeholders.\nYou will receive a JSON object with an array "items": [{"id": number, "text": string}].\n- If "text" contains the exact separator "${CONTEXT_SEPARATOR}", translate each segment to Arabic and preserve the separator unchanged.\n- Preserve any HTML/LaTeX markup exactly.\n- Do NOT modify placeholders of the form __LOCK_n__ or __GLOSSARY_n__.\nReturn ONLY a valid JSON object: {"items":[{"id": number, "text": "translated"}]}.`;
                const payload = { items };
                const signal = this.abortController?.signal;

                let responseText;
                if (provider === 'gemini') responseText = await this.withGeminiJSON(systemPrompt, userInstruction, payload, apiKeyOrUrl, signal);
                else if (provider === 'chatgpt') responseText = await this.withChatGPTJSON(systemPrompt, userInstruction, payload, apiKeyOrUrl, signal);
                else responseText = await this.withLocalModelJSON(systemPrompt, userInstruction, payload, apiKeyOrUrl, localModelName, signal);

                try {
                    const data = JSON.parse(responseText);
                    if (!data || !Array.isArray(data.items)) throw new Error('Invalid JSON structure from model.');
                    return data.items.map(x => ({ id: x.id, text: x.text }));
                } catch (e) {
                    console.warn('JSON parse failed, falling back to delimiter mode.', e);
                    const BATCH_SEPARATOR = TranslatorApp.constants.BATCH_SEPARATOR;
                    const flat = items.map(it => `${it.id}:::${it.text}`).join(BATCH_SEPARATOR);
                    const fallbackPrompt = `${userInstruction}\nNow process items separated by "${BATCH_SEPARATOR}". Each starts with "<id>:::". Return ONLY valid JSON as specified.\n\n${flat}`;
                    let resp;
                    if (provider === 'gemini') resp = await this.withGeminiText(systemPrompt, fallbackPrompt, apiKeyOrUrl, signal);
                    else if (provider === 'chatgpt') resp = await this.withChatGPTText(systemPrompt, fallbackPrompt, apiKeyOrUrl, signal);
                    else resp = await this.withLocalModelText(systemPrompt, fallbackPrompt, apiKeyOrUrl, localModelName, signal);
                    const data2 = JSON.parse(resp);
                    if (!data2 || !Array.isArray(data2.items)) throw new Error('Invalid JSON structure from model (fallback).');
                    return data2.items.map(x => ({ id: x.id, text: x.text }));
                }
            },

            async proofreadInChunks(items, apiKeyOrUrl, provider, localModelName = '') {
                const CHUNK_SIZE = TranslatorApp.constants.CHUNK_SIZE;
                const total = items.length;
                let done = 0;
                const allOut = [];
                for (let i = 0; i < items.length; i += CHUNK_SIZE) {
                    const chunk = items.slice(i, i + CHUNK_SIZE);
                    TranslatorApp.ui.updateProgress(`ØªØ¯Ù‚ÙŠÙ‚ Ù„ØºÙˆÙŠ... (${Math.min(done + chunk.length, total)}/${total})`);
                    const out = await this.proofreadItemsBatch(chunk, apiKeyOrUrl, provider, localModelName);
                    allOut.push(...out);
                    done += chunk.length;
                }
                return allOut;
            },

            async proofreadItemsBatch(items, apiKeyOrUrl, provider, localModelName = '') {
                const userInstruction = `You will receive JSON {"items":[{"id":number,"text":string}]}. Proofread Arabic grammar/style only.
- Do not add/remove content.
- Do not change digits, units, HTML, LaTeX, or any placeholders like __LOCK_n__ or __GLOSSARY_n__.
- Return ONLY {"items":[{"id":number,"text":"polished"}]}.`;
                const payload = { items };
                const signal = this.abortController?.signal;
                let responseText;
                if (provider === 'gemini') responseText = await this.withGeminiJSON('', userInstruction, payload, apiKeyOrUrl, signal);
                else if (provider === 'chatgpt') responseText = await this.withChatGPTJSON('', userInstruction, payload, apiKeyOrUrl, signal);
                else responseText = await this.withLocalModelJSON('', userInstruction, payload, apiKeyOrUrl, localModelName, signal);

                const data = JSON.parse(responseText);
                return data.items;
            },

            async withGeminiJSON(systemPrompt, userInstruction, payload, apiKey, signal) {
                const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-flash-latest:generateContent?key=${apiKey}`;
                const fullPrompt = `${systemPrompt || ''}\n\n${userInstruction}\n\nPayload:\n${JSON.stringify(payload)}`;
                const response = await fetch(apiUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    signal,
                    body: JSON.stringify({ contents: [{ parts: [{ text: fullPrompt }] }], generationConfig: { response_mime_type: "application/json" } })
                });
                if (!response.ok) { let err; try { err = await response.json(); } catch {} throw new Error(`Gemini API Error: ${err?.error?.message || response.statusText}`); }
                const data = await response.json();
                return data.candidates?.[0]?.content?.parts?.[0]?.text || '';
            },
            async withChatGPTJSON(systemPrompt, userInstruction, payload, apiKey, signal) {
                const apiUrl = 'https://api.openai.com/v1/chat/completions';
                const messages = [];
                if (systemPrompt) messages.push({ role: 'system', content: systemPrompt });
                messages.push({ role: 'user', content: `${userInstruction}\n\nPayload:\n${JSON.stringify(payload)}` });
                const candidateModels = ['gpt-4o-mini', 'gpt-4o', 'gpt-4.1-mini'];
                let lastError = null;
                for (const model of candidateModels) {
                    try {
                        const response = await fetch(apiUrl, {
                            method: 'POST', headers: { 'Content-Type': 'application/json', 'Authorization': `Bearer ${apiKey}` }, signal,
                            body: JSON.stringify({ model, messages, temperature: 0.2, response_format: { type: "json_object" } })
                        });
                        if (!response.ok) {
                            let err; try { err = await response.json(); } catch {}
                            lastError = new Error(`ChatGPT API Error: ${err?.error?.message || response.statusText}`);
                            continue;
                        }
                        const data = await response.json();
                        return data.choices?.[0]?.message?.content || '';
                    } catch (e) { lastError = e; }
                }
                throw lastError || new Error('ChatGPT API Error: Unable to complete request');
            },
            async withLocalModelJSON(systemPrompt, userInstruction, payload, url, modelName, signal) {
                const fullPrompt = `${systemPrompt || ''}\n\n${userInstruction}\n\nPayload:\n${JSON.stringify(payload)}\n\nReturn ONLY JSON.`;
                const response = await fetch(url, {
                    method: 'POST', headers: { 'Content-Type': 'application/json' }, signal,
                    body: JSON.stringify({ model: modelName, prompt: fullPrompt, system: '', stream: false, format: 'json' })
                });
                if (!response.ok) throw new Error(`Local server error: ${response.status} ${response.statusText}`);
                const data = await response.json();
                return data.response || '';
            },
            async withGeminiText(systemPrompt, userPrompt, apiKey, signal) {
                const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-flash-latest:generateContent?key=${apiKey}`;
                const fullPrompt = systemPrompt ? `${systemPrompt}\n\n---\n\n${userPrompt}` : userPrompt;
                const response = await fetch(apiUrl, { method: 'POST', headers: { 'Content-Type': 'application/json' }, signal,
                    body: JSON.stringify({ contents: [{ parts: [{ text: fullPrompt }] }] }) });
                if (!response.ok) { const err = await response.json(); throw new Error(`Gemini API Error: ${err.error?.message || response.statusText}`); }
                const data = await response.json();
                return data.candidates?.[0]?.content?.parts?.[0]?.text || '';
            },
            async withChatGPTText(systemPrompt, userPrompt, apiKey, signal) {
                const apiUrl = 'https://api.openai.com/v1/chat/completions';
                const messages = []; if (systemPrompt) messages.push({ role: 'system', content: systemPrompt });
                messages.push({ role: 'user', content: userPrompt });
                const candidateModels = ['gpt-4o-mini', 'gpt-4o', 'gpt-4.1-mini'];
                let lastError = null;
                for (const model of candidateModels) {
                    try {
                        const response = await fetch(apiUrl, {
                            method: 'POST', headers: { 'Content-Type': 'application/json', 'Authorization': `Bearer ${apiKey}` }, signal,
                            body: JSON.stringify({ model, messages, temperature: 0.2 })
                        });
                        if (!response.ok) { const err = await response.json(); lastError = new Error(`ChatGPT API Error: ${err.error?.message || response.statusText}`); continue; }
                        const data = await response.json();
                        return data.choices?.[0]?.message?.content || '';
                    } catch (e) { lastError = e; }
                }
                throw lastError || new Error('ChatGPT API Error: Unable to complete request');
            },
            async withLocalModelText(systemPrompt, userPrompt, url, modelName, signal) {
                const response = await fetch(url, {
                    method: 'POST', headers: { 'Content-Type': 'application/json' }, signal,
                    body: JSON.stringify({ model: modelName, prompt: userPrompt, system: systemPrompt, stream: false })
                });
                if (!response.ok) throw new Error(`Local server error: ${response.status} ${response.statusText}`);
                const data = await response.json();
                return data.response || '';
            }
        },
        
        history: {
            stack: [], currentIndex: -1, timeout: null,
            init() { this.updateButtons(); },
            push(state) {
                const MAX_HISTORY = TranslatorApp.constants.HISTORY_MAX;
                if (this.timeout) clearTimeout(this.timeout);
                this.timeout = setTimeout(() => {
                    this.stack = this.stack.slice(0, this.currentIndex + 1);
                    const snapshot = (window.structuredClone ? structuredClone(state) : JSON.parse(JSON.stringify(state)));
                    this.stack.push(snapshot);
                    if (this.stack.length > MAX_HISTORY) { this.stack.shift(); } else { this.currentIndex++; }
                    this.updateButtons();
                }, 400);
            },
            undo() { if (this.currentIndex > 0) { this.currentIndex--; this.restore(this.stack[this.currentIndex]); } },
            redo() { if (this.currentIndex < this.stack.length - 1) { this.currentIndex++; this.restore(this.stack[this.currentIndex]); } },
            restore(state) {
                TranslatorApp.state.translatedJsonData = (window.structuredClone ? structuredClone(state) : JSON.parse(JSON.stringify(state)));
                TranslatorApp.preview.render(); this.updateButtons(); TranslatorApp.state.hasUnsavedChanges = true;
            },
            updateButtons() {
                TranslatorApp.dom.undoBtn.disabled = this.currentIndex <= 0;
                TranslatorApp.dom.redoBtn.disabled = this.currentIndex >= this.stack.length - 1;
            }
        },

        async startTranslationProcess() {
            const apiProvider = document.querySelector('input[name="apiProvider"]:checked').value;
            let apiKeyOrUrl; let localModelName;
            if (apiProvider === 'gemini') {
                apiKeyOrUrl = this.dom.geminiKeyInput.value.trim();
                if (!this.validation.validateApiKey(apiKeyOrUrl, 'gemini')) return this.ui.showAlert(`Ù…ÙØªØ§Ø­ API Ù„Ù€ Gemini ØºÙŠØ± ØµØ§Ù„Ø­.`, 'error');
            } else if (apiProvider === 'chatgpt') {
                apiKeyOrUrl = this.dom.chatgptKeyInput.value.trim();
                if (!this.validation.validateApiKey(apiKeyOrUrl, 'chatgpt')) return this.ui.showAlert(`Ù…ÙØªØ§Ø­ API Ù„Ù€ ChatGPT ØºÙŠØ± ØµØ§Ù„Ø­.`, 'error');
            } else {
                apiKeyOrUrl = this.dom.localModelUrl.value.trim();
                localModelName = this.dom.localModelName.value.trim();
                if (!apiKeyOrUrl || !localModelName) return this.ui.showAlert('Ø£Ø¯Ø®Ù„ URL ÙˆØ§Ø³Ù… Ø§Ù„Ù†Ù…ÙˆØ°Ø¬ Ø§Ù„Ù…Ø­Ù„ÙŠ.', 'error');
            }
            if (this.state.selectedFilesInfo.length === 0) return this.ui.showAlert('Ø§Ø®ØªØ± Ù…Ù„Ù JSON ÙˆØ§Ø­Ø¯ Ø¹Ù„Ù‰ Ø§Ù„Ø£Ù‚Ù„.', 'error');

            this.ui.showScreen('progress');
            this.dom.translateBtn.disabled = true;
            this.state.translationCache.clear();
            this.state.startTime = Date.now();
            this.api.createAbortController();
            this.state.isTranslating = true;

            try {
                this.ui.updateProgress('Ø¬Ø§Ø±ÙŠ Ù‚Ø±Ø§Ø¡Ø© Ø§Ù„Ù…Ù„ÙØ§Øª...');
                await this.fileHandler.readFilesFromInput();
                this.state.translatedJsonData = JSON.parse(JSON.stringify(this.state.originalJsonData));

                this.ui.updateProgress('Ø¬Ø§Ø±ÙŠ ØªØ­Ø¶ÙŠØ± Ø§Ù„Ù…ØµØ·Ù„Ø­Ø§Øª Ø§Ù„Ù…Ø¹ØªÙ…Ø¯Ø©...');
                const allTexts = this.utils.collectAllTextsFromFiles(this.state.originalJsonData);
                const subject = this.state.selectedSubject;
                const grade = this.state.selectedGrade;
                const ctx = { subject, grade };

                await this.remoteGlossary.fetchApproved(subject, allTexts);
                if (this.dom.useGlossaryCheckbox.checked && this.state.glossary.length > 0) {
                    const merged = { ...(this.remoteGlossary.map || {}) };
                    this.state.glossary.forEach(e => { if (e.term && e.translation) merged[e.term] = e.translation; });
                    this.remoteGlossary.map = merged;
                }

                this.ui.updateProgress('Ø¬Ø§Ø±ÙŠ ØªØ¬Ù…ÙŠØ¹ Ø§Ù„Ù†ØµÙˆØµ Ù„Ù„ØªØ±Ø¬Ù…Ø©...');
                const translationJobs = [];
                const SEP = this.constants.CONTEXT_SEPARATOR;
                const applyGlossary = (txt) => this.remoteGlossary.applyWithPlaceholders(txt);

                this.state.originalJsonData.forEach((file, fileIndex) => {
                    if (file.data.statement) {
                        const src = file.data.statement;
                        const prot = this.quality.protectSegments(src);
                        const gl = applyGlossary(prot.protectedText);
                        translationJobs.push({
                            type: 'single',
                            originalText: gl.modifiedText,
                            placeholders: { locks: prot.placeholders, glossary: gl.placeholders },
                            pointer: { fileIndex, key: 'statement' },
                            sourceRaw: src,
                            tmKey: this.tm.key(src, ctx)
                        });
                    }
                    file.data.parts?.forEach((part, partIndex) => {
                        // **IMPROVEMENT**: Handle gapText questions by translating the 'value' in 'gap_text_keys'
                        if (part.type === 'gapText' && Array.isArray(part.gap_text_keys)) {
                            part.gap_text_keys.forEach((keyItem, keyIndex) => {
                                if (keyItem && typeof keyItem.value === 'string') {
                                    const src = keyItem.value;
                                    const prot = this.quality.protectSegments(src);
                                    const gl = applyGlossary(prot.protectedText);
                                    translationJobs.push({
                                        type: 'single',
                                        originalText: gl.modifiedText,
                                        placeholders: { locks: prot.placeholders, glossary: gl.placeholders },
                                        pointer: { fileIndex, partIndex, key: 'gap_text_keys', keyIndex: keyIndex },
                                        sourceRaw: src,
                                        tmKey: this.tm.key(src, ctx)
                                    });
                                }
                            });
                        }

                        if (part.stem && part.choices && part.choices.length > 0) {
                            const srcParts = [];
                            const lockPlaceholders = [];
                            const glossPlaceholders = [];
                            const blockParts = [];

                            const stemProt = this.quality.protectSegments(part.stem);
                            const stemGl = applyGlossary(stemProt.protectedText);
                            srcParts.push(part.stem);
                            lockPlaceholders.push(stemProt.placeholders);
                            glossPlaceholders.push(stemGl.placeholders);
                            blockParts.push(stemGl.modifiedText);

                            part.choices.forEach(choice => {
                                const prot = this.quality.protectSegments(choice.html_content);
                                const gl = applyGlossary(prot.protectedText);
                                srcParts.push(choice.html_content);
                                lockPlaceholders.push(prot.placeholders);
                                glossPlaceholders.push(gl.placeholders);
                                blockParts.push(gl.modifiedText);
                            });

                            translationJobs.push({
                                type: 'block',
                                originalText: blockParts.join(SEP),
                                placeholders: { locks: lockPlaceholders, glossary: glossPlaceholders },
                                pointer: { fileIndex, partIndex, numChoices: part.choices.length },
                                sourceParts: srcParts,
                                tmKey: this.tm.key(srcParts.join(SEP), ctx)
                            });
                        }

                        if (part.stem && (!part.choices || part.choices.length === 0)) {
                            const src = part.stem;
                            const prot = this.quality.protectSegments(src);
                            const gl = applyGlossary(prot.protectedText);
                            translationJobs.push({
                                type: 'single',
                                originalText: gl.modifiedText,
                                placeholders: { locks: prot.placeholders, glossary: gl.placeholders },
                                pointer: { fileIndex, partIndex, key: 'stem' },
                                sourceRaw: src,
                                tmKey: this.tm.key(src, ctx)
                            });
                        }

                        if (part.answer && typeof part.answer === 'string') {
                            const src = part.answer;
                            const prot = this.quality.protectSegments(src);
                            const gl = applyGlossary(prot.protectedText);
                            translationJobs.push({
                                type: 'single',
                                originalText: gl.modifiedText,
                                placeholders: { locks: prot.placeholders, glossary: gl.placeholders },
                                pointer: { fileIndex, partIndex, key: 'answer' },
                                sourceRaw: src,
                                tmKey: this.tm.key(src, ctx)
                            });
                        }
                    });
                });

                const uniqueJobs = [];
                const seen = new Set();
                for (const job of translationJobs) {
                    if (!seen.has(job.originalText)) {
                        seen.add(job.originalText);
                        uniqueJobs.push(job);
                    }
                }

                this.ui.updateProgress(`ØªØ­Ø¶ÙŠØ± ${uniqueJobs.length} Ù†Øµ ÙØ±ÙŠØ¯...`);

                const useTM = this.dom.useTmCheckbox.checked;
                const jobsToTranslate = [];
                if (uniqueJobs.length > 0) {
                    uniqueJobs.forEach(job => {
                        if (useTM) {
                            const mem = this.tm.get(job.type === 'block' ? (job.sourceParts || []).join(SEP) : job.sourceRaw, ctx);
                            if (mem) {
                                this.state.translationCache.set(job.originalText, mem);
                                return;
                            }
                        }
                        jobsToTranslate.push(job);
                    });
                }

                if (jobsToTranslate.length > 0) {
                    const systemPrompt = this.subjects.buildSystemPrompt();
                    await this.api.translateInChunks(
                        jobsToTranslate, apiKeyOrUrl, apiProvider, localModelName, systemPrompt
                    );
                }

                this.ui.updateProgress('Ø¬Ø§Ø±ÙŠ ØªØ­Ø¯ÙŠØ« Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª...');
                const warnings = [];
                const SEP_REGEX = this.constants.CONTEXT_SEPARATOR;

                for (const job of translationJobs) {
                    const translatedText = this.state.translationCache.get(job.originalText);
                    if (translatedText === undefined) continue;

                    if (job.type === 'single') {
                        let t1 = this.remoteGlossary.revertPlaceholders(translatedText, job.placeholders.glossary);
                        t1 = this.quality.postProcess(t1, ctx);
                        const final_text = this.quality.restoreSegments(t1, job.placeholders.locks);

                        warnings.push(...this.quality.qa.checkNumbers(job.sourceRaw || '', final_text),
                                      ...this.quality.qa.checkSeparator(final_text, SEP_REGEX),
                                      ...this.quality.qa.checkHtmlBalance(final_text));

                        const { fileIndex, partIndex, key, keyIndex } = job.pointer;
                        if (key === 'statement') this.state.translatedJsonData[fileIndex].data.statement = final_text;
                        else if (key === 'answer') this.state.translatedJsonData[fileIndex].data.parts[partIndex].answer = final_text;
                        else if (key === 'stem') this.state.translatedJsonData[fileIndex].data.parts[partIndex].stem = final_text;
                        else if (key === 'gap_text_keys') this.state.translatedJsonData[fileIndex].data.parts[partIndex].gap_text_keys[keyIndex].value = final_text;


                        const srcKey = job.sourceRaw;
                        if (useTM && srcKey) this.tm.put(srcKey, ctx, final_text);
                    } else if (job.type === 'block') {
                        const parts = translatedText.split(SEP_REGEX);
                        const { fileIndex, partIndex, numChoices } = job.pointer;
                        if (parts.length === numChoices + 1) {
                            let stem = this.remoteGlossary.revertPlaceholders(parts[0], job.placeholders.glossary[0]);
                            stem = this.quality.postProcess(stem, ctx);
                            stem = this.quality.restoreSegments(stem, job.placeholders.locks[0]);
                            this.state.translatedJsonData[fileIndex].data.parts[partIndex].stem = stem;
                            warnings.push(...this.quality.qa.checkNumbers(job.sourceParts?.[0] || '', stem),
                                          ...this.quality.qa.checkHtmlBalance(stem));
                            for (let i = 0; i < numChoices; i++) {
                                let ch = this.remoteGlossary.revertPlaceholders(parts[i + 1], job.placeholders.glossary[i + 1]);
                                ch = this.quality.postProcess(ch, ctx);
                                ch = this.quality.restoreSegments(ch, job.placeholders.locks[i + 1]);
                                this.state.translatedJsonData[fileIndex].data.parts[partIndex].choices[i].html_content = ch;
                                warnings.push(...this.quality.qa.checkNumbers(job.sourceParts?.[i + 1] || '', ch),
                                              ...this.quality.qa.checkHtmlBalance(ch));
                            }
                            if (useTM) this.tm.put((job.sourceParts || []).join(SEP_REGEX), ctx, [stem, ...this.state.translatedJsonData[fileIndex].data.parts[partIndex].choices.map(c => c.html_content)].join(SEP_REGEX));
                        } else {
                            console.warn("Mismatch in translated block parts for file", fileIndex, "part", partIndex);
                        }
                    }
                }

                if (warnings.length) {
                    const limited = warnings.slice(0, 8).join(' ');
                    this.ui.showAlert(`Ù…Ø±Ø§Ø¬Ø¹Ø§Øª Ø¢Ù„ÙŠØ©: ${limited}${warnings.length > 8 ? ' ...' : ''}`, 'info', 6000);
                }

                if (this.dom.useProofreadCheckbox.checked) {
                    this.ui.updateProgress('Ø¨Ø¯Ø¡ Ø§Ù„ØªØ¯Ù‚ÙŠÙ‚ Ø§Ù„Ù„ØºÙˆÙŠ Ø§Ù„Ø¢Ù„ÙŠ...');
                    const items = [];
                    const backMap = new Map();
                    let pid = 0;

                    const pushItem = (pointer, text) => {
                        const prot = this.quality.protectSegments(text || '');
                        items.push({ id: pid, text: prot.protectedText });
                        backMap.set(pid, { pointer, locks: prot.placeholders });
                        pid++;
                    };

                    this.state.translatedJsonData.forEach((file, fileIndex) => {
                        const d = file.data;
                        if (d.statement != null) pushItem({ fileIndex, key: 'statement' }, d.statement);
                        d.parts?.forEach((p, partIndex) => {
                            if (p.stem != null) pushItem({ fileIndex, partIndex, key: 'stem' }, p.stem);
                            if (p.answer != null && typeof p.answer === 'string') pushItem({ fileIndex, partIndex, key: 'answer' }, p.answer);
                            p.choices?.forEach((c, choiceIndex) => pushItem({ fileIndex, partIndex, choiceIndex, key: 'choice' }, c.html_content));
                            p.gap_text_keys?.forEach((k, keyIndex) => pushItem({ fileIndex, partIndex, keyIndex, key: 'gap_text_key'}, k.value));
                        });
                    });

                    const out = await this.api.proofreadInChunks(items, apiKeyOrUrl, apiProvider, localModelName);
                    out.forEach(({ id, text }) => {
                        const meta = backMap.get(id); if (!meta) return;
                        let cleaned = this.quality.restoreSegments(text, meta.locks);
                        cleaned = this.quality.normalizeArabicPunct(this.quality.enforceUnits(cleaned));
                        const { fileIndex, partIndex, choiceIndex, keyIndex, key } = meta.pointer;
                        if (key === 'statement') this.state.translatedJsonData[fileIndex].data.statement = cleaned;
                        else if (key === 'stem') this.state.translatedJsonData[fileIndex].data.parts[partIndex].stem = cleaned;
                        else if (key === 'answer') this.state.translatedJsonData[fileIndex].data.parts[partIndex].answer = cleaned;
                        else if (key === 'choice') this.state.translatedJsonData[fileIndex].data.parts[partIndex].choices[choiceIndex].html_content = cleaned;
                        else if (key === 'gap_text_key') this.state.translatedJsonData[fileIndex].data.parts[partIndex].gap_text_keys[keyIndex].value = cleaned;
                    });

                    this.ui.showAlert('ØªÙ… Ø§Ù„ØªØ¯Ù‚ÙŠÙ‚ Ø§Ù„Ù„ØºÙˆÙŠ Ø§Ù„Ø¢Ù„ÙŠ Ø¨Ù†Ø¬Ø§Ø­ âœ…', 'success', 4000);
                }

                this.state.activeScreen = 'preview';
                this.history.push(this.state.translatedJsonData);
                this.session.save();
                this.ui.showScreen('preview');
                this.preview.render();
                const stats = this.statistics.calculate();
                this.ui.renderStatistics(stats);
                this.ui.showAlert('ØªÙ…Øª Ø§Ù„ØªØ±Ø¬Ù…Ø© Ø¨Ù†Ø¬Ø§Ø­ Ø¨Ø¬ÙˆØ¯Ø© Ø§Ø­ØªØ±Ø§ÙÙŠØ© âœ…', 'success');

            } catch (error) {
                if (error?.name !== 'AbortError') {
                    console.error('Translation process failed:', error);
                    this.ui.showAlert(error.message || 'ÙØ´Ù„ ÙÙŠ Ø¹Ù…Ù„ÙŠØ© Ø§Ù„ØªØ±Ø¬Ù…Ø©.', 'error');
                    this.ui.showScreen('setup');
                }
            } finally {
                this.dom.translateBtn.disabled = false;
                this.state.isTranslating = false;
            }
        },
        
        statistics: {
            calculate() {
                let totalTexts = 0, totalWords = 0;
                const count = (text) => {
                    if (text && typeof text === 'string') {
                        totalTexts++;
                        const div = document.createElement('div'); div.innerHTML = text;
                        totalWords += (div.textContent || div.innerText || "").split(/\s+/).filter(Boolean).length;
                    }
                };
                TranslatorApp.state.originalJsonData.forEach(file => {
                    count(file.data.statement);
                    file.data.parts?.forEach(part => {
                        count(part.stem); 
                        if(typeof part.answer === 'string') count(part.answer);
                        part.choices?.forEach(choice => count(choice.html_content));
                        part.gap_text_keys?.forEach(keyItem => count(keyItem.value));
                    });
                });
                const timeElapsed = TranslatorApp.state.startTime ? ((Date.now() - TranslatorApp.state.startTime) / 1000).toFixed(1) : 0;
                return { totalFiles: TranslatorApp.state.selectedFilesInfo.length, totalTexts, totalWords, timeElapsed };
            }
        },

        ui: {
            showScreen(screen) {
                TranslatorApp.state.activeScreen = screen;
                ['setupSection','progressContainer','previewSection','analyticsSection'].forEach(id => TranslatorApp.dom[id]?.classList.add('hidden'));
                if (screen === 'setup') TranslatorApp.dom.setupSection.classList.remove('hidden');
                if (screen === 'progress') TranslatorApp.dom.progressContainer.classList.remove('hidden');
                if (screen === 'preview') { TranslatorApp.dom.previewSection.classList.remove('hidden'); TranslatorApp.dom.analyticsSection.classList.remove('hidden'); }
            },
            updateProgress(text) { TranslatorApp.dom.progressText.textContent = text; },
            showAlert(message, type = 'error', duration = 5000) {
                const colors = { error: 'bg-red-500', success: 'bg-green-500', info: 'bg-blue-500' };
                const alertBox = document.createElement('div');
                alertBox.className = `alert flex justify-between items-center text-white p-4 rounded-lg shadow-xl ${colors[type] || 'bg-gray-500'}`;
                alertBox.innerHTML = `<span>${message}</span><button class="mr-2 text-xl font-bold" aria-label="Ø¥ØºÙ„Ø§Ù‚">&times;</button>`;
                alertBox.querySelector('button').onclick = () => alertBox.remove();
                TranslatorApp.dom.alertContainer.appendChild(alertBox);
                if (duration) setTimeout(() => { alertBox.classList.add('fade-out'); alertBox.addEventListener('transitionend', () => alertBox.remove()); }, duration);
            },
            renderFileList() {
                const { fileList } = TranslatorApp.dom;
                fileList.innerHTML = '';
                if (TranslatorApp.state.selectedFilesInfo.length === 0) return;
                const ul = document.createElement('ul'); ul.className = 'my-4 space-y-2';
                TranslatorApp.state.selectedFilesInfo.forEach((fileInfo, index) => {
                    const li = document.createElement('li'); li.className = 'flex justify-between items-center p-2 rounded-lg';
                    li.style.backgroundColor = 'color-mix(in srgb, var(--primary-color) 5%, var(--card-bg))';
                    li.innerHTML = `<span class="font-medium">${fileInfo.name}</span><button data-index="${index}" class="remove-file-btn text-red-500 hover:text-red-700 font-bold text-xl" aria-label="Ø¥Ø²Ø§Ù„Ø©">&times;</button>`;
                    ul.appendChild(li);
                });
                fileList.appendChild(ul);
                fileList.querySelectorAll('.remove-file-btn').forEach(btn => { btn.onclick = () => TranslatorApp.fileHandler.removeFile(parseInt(btn.dataset.index)); });
            },
            showGlossaryModal(show) { TranslatorApp.dom.glossaryModal.classList.toggle('hidden', !show); },
            showMappedIdsModal(show) { TranslatorApp.dom.mappedIdsModal.classList.toggle('hidden', !show); },
            showSubjectsModal(show) { TranslatorApp.dom.subjectsModal.classList.toggle('hidden', !show); },
            showModal(id, show) { const el = TranslatorApp.dom[id]; if (el) el.classList.toggle('hidden', !show); },
            renderGlossaryList(list) {
                const c = TranslatorApp.dom.glossaryListContainer;
                c.innerHTML = '';
                if (list.length === 0) { c.innerHTML = `<p class="text-center" style="color: var(--secondary-text)">Ù„Ø§ ØªÙˆØ¬Ø¯ Ù…ØµØ·Ù„Ø­Ø§Øª.</p>`; return; }
                const ul = document.createElement('ul'); ul.className = 'space-y-2';
                list.forEach((entry) => {
                    const li = document.createElement('li'); li.className = 'flex justify-between items-center p-2 rounded-md border';
                    li.style.backgroundColor = 'var(--card-bg)'; li.style.borderColor = 'var(--card-border)';
                    const originalIndex = TranslatorApp.state.glossary.findIndex(g => g.term === entry.term);
                    li.innerHTML = `
                        <div>
                            <span class="font-semibold">${entry.term}</span>
                            <span class="mx-2" style="color: var(--secondary-text)">â†’</span>
                            <span>${entry.translation}</span>
                            <span class="text-xs mr-2 px-2 py-1 rounded-full" style="background-color: var(--bg-color);">${entry.category || 'Ø¹Ø§Ù…'}</span>
                        </div>
                        <button data-index="${originalIndex}" class="remove-glossary-btn text-red-500 hover:text-red-700 font-bold" aria-label="Ø­Ø°Ù">&times;</button>`;
                    ul.appendChild(li);
                });
                c.appendChild(ul);
                c.querySelectorAll('.remove-glossary-btn').forEach(btn => btn.onclick = () => TranslatorApp.glossary.delete(parseInt(btn.dataset.index)));
            },
            renderStatistics(stats) {
                const { statsContainer } = TranslatorApp.dom;
                statsContainer.innerHTML = '';
                const map = { 'Ø¥Ø¬Ù…Ø§Ù„ÙŠ Ø§Ù„Ù…Ù„ÙØ§Øª': stats.totalFiles, 'Ø¥Ø¬Ù…Ø§Ù„ÙŠ Ø§Ù„Ù†ØµÙˆØµ': stats.totalTexts, 'Ø¥Ø¬Ù…Ø§Ù„ÙŠ Ø§Ù„ÙƒÙ„Ù…Ø§Øª': stats.totalWords, 'Ø²Ù…Ù† Ø§Ù„ØªØ±Ø¬Ù…Ø© (Ø«)': stats.timeElapsed };
                Object.entries(map).forEach(([label, value]) => {
                    const card = document.createElement('div'); card.className = 'p-4 rounded-lg';
                    card.style.backgroundColor = 'color-mix(in srgb, var(--primary-color) 10%, var(--card-bg))';
                    card.innerHTML = `<div class="text-2xl font-bold" style="color: var(--primary-color);">${value}</div><div class="text-sm" style="color: var(--secondary-text);">${label}</div>`;
                    statsContainer.appendChild(card);
                });
            },
            setSaveIndicator(state) {
                const el = TranslatorApp.dom.saveIndicator; if (!el) return;
                if (state === 'saving') { el.textContent = 'Ø¬Ø§Ø±ÙŠ Ø§Ù„Ø­ÙØ¸...'; el.classList.remove('saved'); }
                else if (state === 'saved') { el.textContent = 'âœ“ Ù…Ø­ÙÙˆØ¸'; el.classList.add('saved'); setTimeout(() => { el.textContent = 'â€”'; el.classList.remove('saved'); }, 2000); }
                else { el.textContent = 'â€”'; el.classList.remove('saved'); }
            }
        },
        
        preview: {
            dmp: new diff_match_patch(),

            renderContentWithMath(htmlString) {
                if (typeof htmlString !== 'string' || !htmlString) {
                    return '<div class="content-root" dir="rtl">&nbsp;</div>';
                }
                // Debug: log problematic content
                if (htmlString.includes('__LOCK') || htmlString.includes('LexicalTheme')) {
                    console.log('Problematic content detected:', htmlString.substring(0, 200));
                }
                
                // If content is just __LOCK__ placeholders, try to restore original content
                if (htmlString.trim() === '__LOCK__' || htmlString.trim() === '__LOCK_I_LOCK__') {
                    // Try to find the original content from the original data
                    const fileIndex = parseInt(document.querySelector('.editable-preview-field')?.dataset.fileIndex || '0', 10);
                    const path = document.querySelector('.editable-preview-field')?.dataset.path || '';
                    if (fileIndex >= 0 && path && TranslatorApp.state.originalJsonData[fileIndex]) {
                        const keys = path.split('.');
                        let originalContent = TranslatorApp.state.originalJsonData[fileIndex].data;
                        for (let i = 0; i < keys.length; i++) {
                            originalContent = originalContent ? originalContent[keys[i]] : '';
                        }
                        if (originalContent && typeof originalContent === 'string') {
                            htmlString = originalContent;
                        }
                    }
                }
                
                // 1) Keep any pre-existing <math-field> as-is to avoid double-wrapping
                htmlString = htmlString.replace(/<math-field[\s\S]*?<\/math-field>/gi, (m) => `__MATHFIELD__${btoa(unescape(encodeURIComponent(m)))}__`);
                const latexRegex = /(\$\$[\s\S]*?\$\$|\$[\s\S]*?\$)/g;
                const parts = htmlString.split(latexRegex);
                const content = parts.map(part => {
                    if (!part) return '';
                    if (part.startsWith('$$') && part.endsWith('$$')) {
                        const latex = part.slice(2, -2).replace(/"/g, '&quot;');
                        return `<math-field default-mode="math" value="${latex}" virtual-keyboard-mode="onfocus" use-shared-virtual-keyboard dir="ltr"></math-field>`;
                    }
                    if (part.startsWith('$') && part.endsWith('$')) {
                        const latex = part.slice(1, -1).replace(/"/g, '&quot;');
                        return `<math-field default-mode="inline-math" value="${latex}" virtual-keyboard-mode="onfocus" use-shared-virtual-keyboard dir="ltr"></math-field>`;
                    }
                    // Inject editable math-fields for common chemical formulas in plain text
                    let injected = this.injectChemistryMathFields(part);
                    // Decorate blanks ___ to visible slots (preview-only)
                    injected = this.decorateBlanks(injected);
                    const sanitized = TranslatorApp.security.sanitize(injected)
                        // normalize multiplication sign to match system rendering
                        .replace(/\bx\b/g, 'Ã—');
                    const hasBlock = /<\s*(table|ul|ol|li|div|p|pre|code|thead|tbody|tr|td|th|img|audio)\b/i.test(sanitized);
                    return hasBlock ? sanitized : `<span>${sanitized}</span>`;
                }).join('');
                // 2) Restore original math-field fragments
                const restored = content.replace(/__MATHFIELD__([A-Za-z0-9+/=]+)__/g, (_, b64) => {
                    try { return decodeURIComponent(escape(atob(b64))); } catch { return ''; }
                });
                return `<div class="content-root" dir="rtl">${restored}</div>`;
            },

            // Convert plain chemical formulas (e.g., NaHCO3, H2SO4, Ca(OH)2) into inline math-fields
            injectChemistryMathFields(text) {
                if (!text || typeof text !== 'string') return text;
                const escapeAttr = (s) => (s || '').replace(/"/g, '&quot;');
                // Basic LaTeX conversion: element digits -> _{digits}, parenthesis digits -> _{digits}
                const toLatex = (formula) => {
                    let out = formula;
                    out = out.replace(/([A-Za-z][a-z]?)\s*(\d+)/g, '$1_{$2}');
                    out = out.replace(/\)(\d+)/g, ')_{$1}');
                    return out;
                };
                // Regex for typical chemical formula tokens
                const chemRegex = /\b(?:[A-Z][a-z]?\d*)+(?:\([A-Za-z\d]+\)\d*)*\b/g;
                return text.replace(chemRegex, (match) => {
                    // Avoid converting if already inside an HTML tag like <span> or attributes
                    // Heuristic: skip if match is immediately preceded by '&' (entity) or within a tag
                    // Since we sanitize later and we run on plain text chunks, this is usually safe
                    const latex = escapeAttr(toLatex(match));
                    return `<math-field default-mode="inline-math" value="${latex}" virtual-keyboard-mode="onfocus" use-shared-virtual-keyboard dir="ltr"></math-field>`;
                });
            },

            decorateBlanks(text) {
                if (!text || typeof text !== 'string') return text;
                // Replace sequences of 3+ underscores with a visual blank slot
                return text.replace(/_{3,}/g, (m) => `<span class="blank-slot" data-blank="${'_'.repeat(m.length)}"></span>`);
            },
            
            handlePreviewFieldUpdate(fieldContainer) {
                if (!fieldContainer) return;
                
                const path = fieldContainer.dataset.path;
                const fileIndex = parseInt(fieldContainer.dataset.fileIndex, 10);
                
                let newContent = '';
                const root = fieldContainer.querySelector('.content-root');
                (root ? root.childNodes : []).forEach(node => {
                    if (node.tagName === 'SPAN') {
                        // If span is a preview blank-slot, persist original underscores length
                        if (node.classList && node.classList.contains('blank-slot')) {
                            const raw = node.getAttribute('data-blank') || '___';
                            newContent += raw;
                        } else {
                            newContent += node.innerHTML;
                        }
                    } else if (node.tagName === 'MATH-FIELD') {
                        const delimiter = node.getAttribute('default-mode') === 'math' ? '$$' : '$';
                        // If the math-field was originally from the source (read-only attr present), preserve element HTML
                        if (node.hasAttribute('data-origin') || node.getAttribute('read-only') === 'true') {
                            newContent += node.outerHTML;
                        } else {
                            newContent += `${delimiter}${node.value}${delimiter}`;
                        }
                    } else if (node.nodeType === Node.ELEMENT_NODE) {
                        // Preserve any other HTML element (e.g., table, div)
                        newContent += node.outerHTML;
                    } else if (node.nodeType === Node.TEXT_NODE) {
                        newContent += node.textContent;
                    }
                });
                
                // If content is empty or just whitespace, save as empty string instead of __LOCK__
                if (!newContent.trim()) {
                    newContent = '';
                }
                
                this.updateData(fileIndex, path, newContent);
                this.updateDiff(fileIndex, path);
                const statusEl = document.getElementById(`status-field-${fileIndex}-${path.replace(/\./g, '-')}`);
                if(statusEl) {
                    statusEl.className = 'status-dot status-edited';
                    statusEl.title = 'ØªÙ… Ø§Ù„ØªØ¹Ø¯ÙŠÙ„ ÙŠØ¯ÙˆÙŠØ§Ù‹';
                }
            },

            render() {
                const { previewContainer } = TranslatorApp.dom;
                previewContainer.innerHTML = '';

                TranslatorApp.state.translatedJsonData.forEach((file, fileIndex) => {
                    const fileAccordion = document.createElement('div');
                    fileAccordion.className = 'preview-card rounded-2xl shadow-lg overflow-hidden';
                    
                    const header = document.createElement('button');
                    header.className = 'accordion-header';
                    header.innerHTML = `ğŸ“„ ${file.name}`;
                    header.onclick = (e) => {
                        const content = e.currentTarget.nextElementSibling;
                        e.currentTarget.classList.toggle('active');
                        if (content.style.maxHeight) {
                            content.style.maxHeight = null;
                            content.classList.remove('open');
                        } else {
                            content.classList.add('open');
                            content.style.maxHeight = content.scrollHeight + "px";
                        }
                    };

                    const content = document.createElement('div');
                    content.className = 'accordion-content';
                    content.innerHTML = this.renderFileContent(file.data, fileIndex);

                    fileAccordion.appendChild(header);
                    fileAccordion.appendChild(content);
                    previewContainer.appendChild(fileAccordion);
                    
                    this.generateInitialDiffs(fileIndex);
                });
                // Activate MathLive keyboard for all math-fields in preview
                this.prepareInteractiveMathFields();
            },

            renderReadOnlyField(label, value) {
                if (value === undefined || value === null) return '';
                // **IMPROVEMENT**: Handle arrays by joining them for display
                const displayValue = Array.isArray(value) ? value.join(', ') : String(value);
                return `
                    <div class="border rounded-lg p-4" style="border-color: var(--card-border);">
                        <h5 class="font-bold flex items-center mb-2">${label}</h5>
                        <div class="p-3 rounded-lg text-sm" style="background-color: var(--bg-color); color: var(--secondary-text);">${TranslatorApp.security.sanitize(displayValue)}</div>
                    </div>`;
            },

                        renderFileContent(data, fileIndex) {
                let html = '<div class="space-y-6">';
                const renderField = (label, originalValue, translatedValue, path) => {
                    if (originalValue === undefined || originalValue === null) return '';
                    const fieldId = `field-${fileIndex}-${path.replace(/\./g, '-')}`;
                    const diffId = `diff-${fieldId}`;
                    const statusId = `status-${fieldId}`;

                    return `
                        <div class="border rounded-lg p-4" style="border-color: var(--card-border);">
                            <div class="flex justify-between items-center mb-2">
                                <h5 class="font-bold flex items-center">${label} <span id="${statusId}" class="status-dot status-translated" title="ØªÙ…Øª Ø§Ù„ØªØ±Ø¬Ù…Ø©"></span></h5>
                                <div class="flex gap-2">
                                    <button class="text-xs font-semibold py-1 px-2 rounded" onclick="TranslatorApp.preview.copyOriginalText(this)">Ù†Ø³Ø® Ø§Ù„Ø£ØµÙ„ÙŠ</button>
                                    <button class="text-xs font-semibold py-1 px-2 rounded" onclick="document.getElementById('${diffId}').parentNode.classList.toggle('hidden')">Ø¹Ø±Ø¶/Ø¥Ø®ÙØ§Ø¡ Ø§Ù„ÙØ±ÙˆÙ‚Ø§Øª</button>
                                </div>
                            </div>
                            <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
                                <div>
                                    <p class="text-sm font-semibold mb-1" style="color: var(--secondary-text);">Ø§Ù„Ø£ØµÙ„ÙŠ</p>
                                    <div class="original-text-readonly p-3 rounded-lg text-sm h-full" style="background-color: var(--bg-color); overflow:auto;">${TranslatorApp.security.sanitize(originalValue)}</div>
                                </div>
                                <div>
                                    <p class="text-sm font-semibold mb-1" style="color: var(--success-color);">Ø§Ù„Ù…ØªØ±Ø¬Ù… (Ù‚Ø§Ø¨Ù„ Ù„Ù„ØªØ¹Ø¯ÙŠÙ„)</p>
                                    <div id="${fieldId}" 
                                         contenteditable="true"
                                         class="editable-preview-field"
                                         data-path="${path}"
                                         data-file-index="${fileIndex}">
                                         ${this.renderContentWithMath(translatedValue || originalValue)}
                                    </div>
                                </div>
                            </div>
                            <div class="mt-4 hidden">
                                 <p class="text-sm font-semibold mb-1" style="color: var(--secondary-text);">Ù…Ù‚Ø§Ø±Ù†Ø© Ø§Ù„ÙØ±ÙˆÙ‚Ø§Øª</p>
                                <div id="${diffId}" class="diff-view"></div>
                            </div>
                        </div>`;
                };
                
                html += renderField('Ø§Ù„Ø¨ÙŠØ§Ù† (Statement)', TranslatorApp.state.originalJsonData[fileIndex].data.statement, data.statement, 'statement');

                data.parts?.forEach((part, partIndex) => {
                    html += '<div class="border-t pt-4 mt-4 space-y-4" style="border-color: var(--card-border);">';
                    html += `<h5 class="font-semibold text-md" style="color: var(--secondary-text);">Ø§Ù„Ø¬Ø²Ø¡ ${partIndex + 1} (Ø§Ù„Ù†ÙˆØ¹: ${part.type || 'ØºÙŠØ± Ù…Ø­Ø¯Ø¯'})</h5>`;
                    const originalPart = TranslatorApp.state.originalJsonData[fileIndex].data.parts[partIndex];
                    
                    html += renderField('Ø§Ù„Ø³Ø¤Ø§Ù„ (Stem)', originalPart.stem, part.stem, `parts.${partIndex}.stem`);
                    
                    if (originalPart.answer) {
                        if (typeof originalPart.answer === 'string') {
                            html += renderField('Ø§Ù„Ø¥Ø¬Ø§Ø¨Ø© (Answer)', originalPart.answer, part.answer, `parts.${partIndex}.answer`);
                        } else if (typeof originalPart.answer === 'object' && originalPart.answer.hasOwnProperty('value')) {
                            // Allow editing if the translated part kept the same shape (object with value)
                            html += renderField('Ø§Ù„Ø¥Ø¬Ø§Ø¨Ø© (Answer)', originalPart.answer.value, (part.answer && part.answer.value) || originalPart.answer.value, `parts.${partIndex}.answer.value`);
                        } else {
                             html += this.renderReadOnlyField('Ø§Ù„Ø¥Ø¬Ø§Ø¨Ø© (Answer - ØºÙŠØ± Ù‚Ø§Ø¨Ù„Ø© Ù„Ù„ØªØ±Ø¬Ù…Ø©)', JSON.stringify(originalPart.answer));
                        }
                    }
                    
                    part.choices?.forEach((choice, choiceIndex) => {
                        const originalChoice = originalPart.choices[choiceIndex];
                        html += renderField(`Ø®ÙŠØ§Ø± ${choiceIndex + 1}`, originalChoice.html_content, choice.html_content, `parts.${partIndex}.choices.${choiceIndex}.html_content`);
                    });

                    // **IMPROVEMENT**: Render gap_text_keys for translation
                    part.gap_text_keys?.forEach((keyItem, keyIndex) => {
                        const originalKeyItem = originalPart.gap_text_keys[keyIndex];
                        html += renderField(`ÙƒÙ„Ù…Ø© Ø§Ù„ÙØ±Ø§Øº ${keyIndex + 1}`, originalKeyItem.value, keyItem.value, `parts.${partIndex}.gap_text_keys.${keyIndex}.value`);
                    });

                    html += '</div>';
                });

                html += '</div>';
                return html;
            },

            updateData(fileIndex, path, value) {
                const keys = path.split('.');
                let current = TranslatorApp.state.translatedJsonData[fileIndex].data;
                for (let i = 0; i < keys.length - 1; i++) {
                    current = current[keys[i]];
                }
                current[keys[keys.length - 1]] = value;
                
                TranslatorApp.history.push(TranslatorApp.state.translatedJsonData);
                TranslatorApp.state.hasUnsavedChanges = true;
            },

            generateInitialDiffs(fileIndex) {
                const originalData = TranslatorApp.state.originalJsonData[fileIndex].data;
                const processPath = (path) => {
                    if (originalData === undefined || originalData === null) return;
                    this.updateDiff(fileIndex, path);
                };
                processPath('statement');
                originalData.parts?.forEach((part, partIndex) => {
                    processPath(`parts.${partIndex}.stem`);
                    if(typeof part.answer === 'string') processPath(`parts.${partIndex}.answer`);
                    part.choices?.forEach((choice, choiceIndex) => {
                        processPath(`parts.${partIndex}.choices.${choiceIndex}.html_content`);
                    });
                     part.gap_text_keys?.forEach((keyItem, keyIndex) => {
                        processPath(`parts.${partIndex}.gap_text_keys.${keyIndex}.value`);
                    });
                });
            },

            updateDiff(fileIndex, path) {
                const fieldId = `field-${fileIndex}-${path.replace(/\./g, '-')}`;
                const diffId = `diff-${fieldId}`;
                const diffContainer = document.getElementById(diffId);
                if (!diffContainer) return;

                const keys = path.split('.');
                let originalText = TranslatorApp.state.originalJsonData[fileIndex].data;
                let translatedText = TranslatorApp.state.translatedJsonData[fileIndex].data;
                for (let i = 0; i < keys.length; i++) {
                    originalText = originalText ? originalText[keys[i]] : '';
                    translatedText = translatedText ? translatedText[keys[i]] : '';
                }
                
                const cleanOriginal = this.plainTextForDiff(originalText || '');
                const cleanTranslated = this.plainTextForDiff(translatedText || '');
                
                diffContainer.innerHTML = this.createDiffHtml(cleanOriginal, cleanTranslated);
            },

            prepareInteractiveMathFields() {
                try {
                    const mathFields = TranslatorApp.dom.previewContainer.querySelectorAll('math-field');
                    mathFields.forEach(mf => {
                        mf.removeAttribute('read-only');
                        mf.setAttribute('virtual-keyboard-mode', 'onfocus');
                        mf.setAttribute('use-shared-virtual-keyboard', '');
                        if (!mf.hasAttribute('dir')) mf.setAttribute('dir', 'ltr');
                        mf.addEventListener('focus', () => {
                            try { if (typeof mf.executeCommand === 'function') mf.executeCommand('showVirtualKeyboard'); } catch {}
                        }, { once: false });
                    });
                } catch {}
            },

            createDiffHtml(text1, text2) {
                const d = this.dmp.diff_main(text1, text2);
                this.dmp.diff_cleanupSemantic(d);
                return this.dmp.diff_prettyHtml(d);
            },
            
            plainTextForDiff(html) {
                const div = document.createElement('div');
                div.innerHTML = html;
                return div.textContent || div.innerText || '';
            },

            copyOriginalText(button) {
                const fieldContainer = button.closest('.border').querySelector('.original-text-readonly');
                if (fieldContainer) {
                    const textToCopy = fieldContainer.innerHTML;
                    const textArea = document.createElement('textarea');
                    textArea.value = textToCopy;
                    
                    textArea.style.position = 'fixed';
                    textArea.style.top = '0';
                    textArea.style.left = '0';
                    textArea.style.width = '2em';
                    textArea.style.height = '2em';
                    textArea.style.padding = '0';
                    textArea.style.border = 'none';
                    textArea.style.outline = 'none';
                    textArea.style.boxShadow = 'none';
                    textArea.style.background = 'transparent';

                    document.body.appendChild(textArea);
                    textArea.focus();
                    textArea.select();

                    try {
                        const successful = document.execCommand('copy');
                        if (successful) {
                            TranslatorApp.ui.showAlert('ØªÙ… Ù†Ø³Ø® Ø§Ù„Ù†Øµ Ø§Ù„Ø£ØµÙ„ÙŠ!', 'success', 2000);
                        } else {
                            TranslatorApp.ui.showAlert('ÙØ´Ù„ Ù†Ø³Ø® Ø§Ù„Ù†Øµ.', 'error', 2000);
                        }
                    } catch (err) {
                        console.error('Fallback: Oops, unable to copy', err);
                        TranslatorApp.ui.showAlert('ÙØ´Ù„ Ù†Ø³Ø® Ø§Ù„Ù†Øµ.', 'error', 2000);
                    }

                    document.body.removeChild(textArea);
                }
            },

            filter() {
                const term = TranslatorApp.dom.searchPreview.value.toLowerCase();
                const accordions = document.querySelectorAll('#previewContainer > div');
                accordions.forEach(accordion => {
                    const content = accordion.textContent.toLowerCase();
                    const isVisible = content.includes(term);
                    accordion.style.display = isVisible ? '' : 'none';
                });
            }
        },
        export: {
            exportAs(format) {
                return (format === 'csv') ? this.toCsv() : this.toJson();
            },
            async toJson() {
                const useMappedIds = TranslatorApp.dom.useMappedIdsCheckbox.checked;
                let mappedIds = [];
                let idCounter = 0;

                if (useMappedIds) {
                    try {
                        mappedIds = JSON.parse(TranslatorApp.dom.mappedIdsInput.value);
                        if (!Array.isArray(mappedIds)) throw new Error('not array');
                    } catch {
                        return TranslatorApp.ui.showAlert('Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ù…Ø¹Ø±ÙØ§Øª (mapped_id) ØºÙŠØ± ØµØ§Ù„Ø­Ø©. ÙŠØ±Ø¬Ù‰ Ø§Ù„ØªØ£ÙƒØ¯ Ù…Ù† Ø£Ù†Ù‡Ø§ Ù…ØµÙÙˆÙØ© JSON ØµØ­ÙŠØ­Ø©.', 'error');
                    }
                }

                const zip = new JSZip();

                TranslatorApp.state.translatedJsonData.forEach(file => {
                    const originalFile = TranslatorApp.state.originalJsonData.find(f => f.name === file.name);
                    const finalData = JSON.parse(JSON.stringify(originalFile.data));

                    finalData.statement = file.data.statement;
                    if (finalData.parts) {
                        finalData.parts.forEach((part, partIndex) => {
                            const translatedPart = file.data.parts[partIndex];
                            if (translatedPart) {
                                part.stem = translatedPart.stem;
                                part.answer = translatedPart.answer;
                                if (part.choices) {
                                    part.choices.forEach((choice, choiceIndex) => {
                                        if (translatedPart.choices && translatedPart.choices[choiceIndex]) {
                                            choice.html_content = translatedPart.choices[choiceIndex].html_content;
                                        }
                                    });
                                }
                                if (part.gap_text_keys) {
                                     part.gap_text_keys.forEach((keyItem, keyIndex) => {
                                        if (translatedPart.gap_text_keys && translatedPart.gap_text_keys[keyIndex]) {
                                            keyItem.value = translatedPart.gap_text_keys[keyIndex].value;
                                        }
                                    });
                                }
                            }
                        });
                    }

                    finalData.metadata = finalData.metadata || {};
                    finalData.metadata.title = "";
                    finalData.metadata.language = 'ar';
                    finalData.metadata.dialect = ['modern_standard'];
                    finalData.metadata.country = 'eg';
                    finalData.metadata.source_id = null;

                    const stripHtml = (html) => {
                        if (!html) return "";
                        const doc = new DOMParser().parseFromString(html, 'text/html');
                        return doc.body.textContent || "";
                    };
                    
                    const cleanStatement = stripHtml(finalData.statement);
                    const cleanStem = finalData.parts?.[0]?.stem ? stripHtml(finalData.parts[0].stem) : '';
                    let description = (cleanStatement + ' ' + cleanStem).trim();
                    finalData.metadata.description = description;

                    let fileNameToUse = file.name;
                    if (useMappedIds && idCounter < mappedIds.length) {
                        const newMappedId = mappedIds[idCounter];
                        finalData.metadata.mapped_id = newMappedId;
                        fileNameToUse = `${newMappedId}.json`;
                        idCounter++;
                    } else {
                         finalData.metadata.mapped_id = finalData.metadata.id;
                    }
                    
                    zip.file(fileNameToUse, JSON.stringify(finalData, null, 2));
                });

                if (useMappedIds && idCounter < TranslatorApp.state.translatedJsonData.length) {
                    TranslatorApp.ui.showAlert(`ØªØ­Ø°ÙŠØ±: Ø¹Ø¯Ø¯ Ø§Ù„Ù…Ø¹Ø±ÙØ§Øª (${idCounter}) Ø£Ù‚Ù„ Ù…Ù† Ø¹Ø¯Ø¯ Ø§Ù„Ù…Ù„ÙØ§Øª (${TranslatorApp.state.translatedJsonData.length}).`, 'error');
                }

                try {
                    const content = await zip.generateAsync({ type: "blob" });
                    const link = document.createElement("a");
                    link.href = URL.createObjectURL(content);
                    link.download = `translated_questions_${new Date().toISOString().replace(/[:.]/g, '-')}.zip`;
                    document.body.appendChild(link);
                    link.click();
                    document.body.removeChild(link);
                    TranslatorApp.ui.showAlert('ØªÙ… Ø¥Ù†Ø´Ø§Ø¡ Ù…Ù„Ù ZIP Ø¨Ù†Ø¬Ø§Ø­!', 'success');
                } catch (e) {
                    console.error(e);
                    TranslatorApp.ui.showAlert('ÙØ´Ù„ Ø¥Ù†Ø´Ø§Ø¡ Ù…Ù„Ù ZIP.', 'error');}
            },
            async toCsv() {
                let csv = '\uFEFFFileName,PartIndex,Type,OriginalText,TranslatedText\r\n';
                TranslatorApp.state.originalJsonData.forEach((originalFile, fileIndex) => {
                    const translatedFile = TranslatorApp.state.translatedJsonData[fileIndex];
                    const fileName = originalFile.name;
                    const addRow = (partIndex, type, originalText, translatedText) => {
                        const escape = (str) => { const div = document.createElement('div'); div.innerHTML = str || ''; const text = (div.textContent || div.innerText || '').replace(/"/g, '""'); return `"${text}"`; };
                        csv += [fileName, partIndex, type, escape(originalText), escape(translatedText)].join(',') + '\r\n';
                    };
                    addRow(0, 'statement', originalFile.data.statement, translatedFile.data.statement);
                    originalFile.data.parts.forEach((part, partIndex) => {
                        const translatedPart = translatedFile.data.parts[partIndex];
                        addRow(partIndex + 1, 'stem', part.stem, translatedPart.stem);
                        if(typeof part.answer === 'string') {
                            addRow(partIndex + 1, 'answer', part.answer, translatedPart.answer);
                        } else if (part.answer && typeof part.answer === 'object' && part.answer.hasOwnProperty('value')) {
                            addRow(partIndex + 1, 'answer', part.answer.value, translatedPart.answer.value);
                        }
                        part.choices.forEach((choice, choiceIndex) => {
                            addRow(partIndex + 1, `choice_${choiceIndex + 1}`, choice.html_content, translatedPart.choices[choiceIndex].html_content);
                        });
                        part.gap_text_keys?.forEach((keyItem, keyIndex) => {
                             addRow(partIndex + 1, `gap_text_key_${keyIndex + 1}`, keyItem.value, translatedPart.gap_text_keys[keyIndex].value);
                        });
                    });
                });
                const blob = new Blob([csv], { type: 'text/csv;charset=utf-8' });
                const url = URL.createObjectURL(blob);
                const link = document.createElement("a"); link.href = url; link.download = `translated_data_${new Date().toISOString().replace(/[:.]/g,'-')}.csv`;
                document.body.appendChild(link); link.click(); document.body.removeChild(link); URL.revokeObjectURL(url);
                TranslatorApp.ui.showAlert('ØªÙ… Ø¥Ù†Ø´Ø§Ø¡ Ù…Ù„Ù CSV Ø¨Ù†Ø¬Ø§Ø­!', 'success');
            }
        }
        ,
        annotator: {
            canvas: null,
            fabricCanvas: null,
            currentImage: null,
            open() {
                const images = TranslatorApp.dom.previewContainer.querySelectorAll('img');
                if (!images.length) { TranslatorApp.ui.showAlert('Ù„Ø§ ØªÙˆØ¬Ø¯ ØµÙˆØ± ÙÙŠ Ø§Ù„ØµÙØ­Ø© Ø§Ù„Ø­Ø§Ù„ÙŠØ©.', 'info'); return; }
                // Use the first image in view for simplicity
                this.currentImage = images[0];
                TranslatorApp.ui.showModal('imageAnnotatorModal', true);
                setTimeout(() => this.initCanvas(), 0);
            },
            close() { TranslatorApp.ui.showModal('imageAnnotatorModal', false); },
            initCanvas() {
                const canvasEl = TranslatorApp.dom.imageAnnotatorCanvas;
                const img = this.currentImage;
                if (!canvasEl || !img) return;
                canvasEl.width = img.naturalWidth || img.width;
                canvasEl.height = img.naturalHeight || img.height;
                this.fabricCanvas = new fabric.Canvas(canvasEl, { selection: true });
                fabric.Image.fromURL(img.src, (oImg) => {
                    oImg.selectable = false; oImg.evented = false; oImg.scaleToWidth(canvasEl.width);
                    this.fabricCanvas.add(oImg).sendToBack(oImg);
                }, { crossOrigin: 'anonymous' });
                // Add helper text tool with RTL support
                this.fabricCanvas.on('mouse:dblclick', (e) => {
                    const pointer = this.fabricCanvas.getPointer(e.e);
                    const textbox = new fabric.Textbox('Ù†Øµ', {
                        left: pointer.x, top: pointer.y, fontSize: 24, fill: '#111827', backgroundColor: 'rgba(255,255,255,0.7)'
                    });
                    this.fabricCanvas.add(textbox).setActiveObject(textbox);
                });
            },
            save() {
                if (!this.fabricCanvas) return;
                const dataUrl = this.fabricCanvas.toDataURL({ format: 'png', quality: 1 });
                // Replace the image in preview with annotated version (non-destructive â€“ just in UI)
                this.currentImage.src = dataUrl;
                TranslatorApp.state.hasUnsavedChanges = true;
                this.close();
                TranslatorApp.ui.showAlert('ØªÙ… Ø­ÙØ¸ Ø§Ù„ØªØ¹Ø¯ÙŠÙ„Ø§Øª Ø¹Ù„Ù‰ Ø§Ù„ØµÙˆØ±Ø© (Ù…Ø­Ù„ÙŠØ§Ù‹).', 'success');
            }
        }
    };

    document.addEventListener('DOMContentLoaded', () => TranslatorApp.init());
    </script>
</body>
</html>
